{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"limnd2 package","text":"<p>Warning</p> <p>This Python package is not yet available for the public, both the package and the documentation is still being worked on.</p> <p><code>.nd2</code> (Nikon NIS Elements) file reader and writer in Python.</p>"},{"location":"#installation","title":"Installation","text":"PyPIManual (Windows)Manual (Linux) <p>Warning</p> <p>This Python package is not released on PyPI yet, use manual installation.</p> <p>You can install this package from PyPI by running following command:</p> <pre><code>pip install limnd2\n</code></pre> <p>Run following commands in a folder where you want to install this package.</p> <pre><code>git clone https://github.com/Laboratory-Imaging/limnd2.git\ncd limnd2\npython -m venv env\nenv\\Scripts\\activate\npython -m pip install --upgrade pip\npip install -r requirements.txt\n</code></pre> <p>Run following commands in a folder where you want to install this package.</p> <pre><code>git clone https://github.com/Laboratory-Imaging/limnd2.git\ncd limnd2\npython3 -m venv env\nsource env/bin/activate\npython3 -m pip install --upgrade pip\npip install -r requirements.txt\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#reading-nd2-files","title":"Reading <code>.nd2</code> files","text":"<p>An example Python file showcasing how to read an <code>.nd2</code> file with this library is found at GitHub repo for this page: example_reader.py.</p>"},{"location":"#opening-nd2-file","title":"Opening <code>.nd2</code> file","text":"<p>An <code>.nd2</code> file can be opened using <code>Nd2Reader</code> class like this:</p> <pre><code>nd2 = limnd2.Nd2Reader(\"file.nd2\")\n</code></pre> <p>However it is recommended to open <code>.nd2</code> files (especially when writing) using <code>with</code> statement to automatically close the file.</p> example_reader.py<pre><code>with limnd2.Nd2Reader(\"file.nd2\") as nd2:\n</code></pre>"},{"location":"#getting-summary-information","title":"Getting summary information","text":"<p>Quick access to information about the file can be gained with <code>generalImageInfo</code> dictionary:</p> example_reader.py<pre><code>print(\"Summary information\")\nfor key, value in nd2.generalImageInfo.items():\n    print(f\"{key}: {value}\")\n</code></pre> See example output <pre><code>Summary information\nfilename: file.nd2\npath: C:\\Users\\user\\Desktop\\nd2_files\nbit_depth: 32bit float\nloops: XY(25), Z(5)\ndimension: 1024 x 1024 (2 comps 32bit float) x 125 frames: XY(25), Z(5)\nfile_size: 6732537856\nframe_res: 1024 x 1024\nvolume_size: 40MB\nsizes: 6GB on disk, 8MB frame, 40MB volume\ncalibration: 0.432 \u00b5m/px\nmtime: 06/07/21 14:17:56\napp_created: NIS-Elements AR 5.20.00 (Build 1423)\n</code></pre>"},{"location":"#getting-text-information","title":"Getting text information","text":"<p>More information about components can be in <code>imageTextInfo</code> dataclass, though this information is stored as a string:</p> example_reader.py<pre><code>print(\"More information\")\nfor key, value in nd2.imageTextInfo.to_dict().items():\n    print(f\"{key}: {value}\")\n</code></pre> See example output <pre><code>More information\nimageId:\ntype:\ngroup:\nsampleId:\nauthor:\ndescription: Metadata:\nDimensions: XY(25) x Z(5)\nCamera Name: Nikon A1 LFOV\nNumerical Aperture: 1.15\nRefractive Index: 1.333\nNumber of Picture Planes: 2\nPlane #1:\n    Name: DETECTOR A\n    Component Count: 1\n    Modality: AUX\n    Microscope Settings:   Microscope: Ti2 Microscope\n    External Phase, position: 0\n    Polarizer, position: Out\n    DIC Prism, position: In\n    Bertrand Lens, position: Out\n    Nikon Ti2, FilterChanger(Turret-Lo): 1 (Empty)\n    Nikon Ti2, FilterChanger(Turret-Up): 1 (Empty)\n    Nikon Ti2, Shutter(FL-Lo): Closed\n    Nikon Ti2, Shutter(FL-Up): Closed\n    LightPath: L100\n    Analyzer Slider: Extracted\n    Condenser: 3 (OPEN)\n    PFS, state: Off\n    PFS, offset: 5700\n    PFS, mirror: Inserted\n    PFS, Dish Type: Glass\n    Zoom: 1.00x\n    Eyepiece Ports:\n        Port 1: Off  (Camera)\n        Port 2: On  (Eye)\n\n    LAPP Upper Ports:\n        Port 1: Off  (1)\n        Port 2: On  (2)\n\n    LAPP Lower Ports:\n        Port 1: Off  (H-TIRF Direct XY-F)\n        Port 2: Off  (2)\n        Port 3: On  (3)\n\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    E-TIRF1 Angle: 0.0\n    E-TIRF1 Direction: 0.0\n    NIDAQ, FilterChanger(FilterWheel): 1 (Empty)\n    NIDAQ, Shutter(LUN-F): Closed\n    NIDAQ, Shutter(LUN4): Closed\n    NIDAQ, Shutter(AUX1): Closed\n    NIDAQ, Shutter(EPI): Closed\n    NIDAQ, MultiLaser(LUN-F):\n        Line:1; ExW:405; Power: 34.8; On\n\n    NIDAQ, MultiLaser(LUN4):\n        Line:1; ExW:405; Power: 30.0; Off\n        Line:2; ExW:488; Power: 30.0; Off\n        Line:3; ExW:561; Power: 30.0; On\n        Line:4; ExW:640; Power: 30.0; Off\n\nPlane #2:\n    Name: DETECTOR B\n    Component Count: 1\n    Modality: AUX\n    Microscope Settings:   Microscope: Ti2 Microscope\n    External Phase, position: 0\n    Polarizer, position: Out\n    DIC Prism, position: In\n    Bertrand Lens, position: Out\n    Nikon Ti2, FilterChanger(Turret-Lo): 1 (Empty)\n    Nikon Ti2, FilterChanger(Turret-Up): 1 (Empty)\n    Nikon Ti2, Shutter(FL-Lo): Closed\n    Nikon Ti2, Shutter(FL-Up): Closed\n    LightPath: L100\n    Analyzer Slider: Extracted\n    Condenser: 3 (OPEN)\n    PFS, state: Off\n    PFS, offset: 5700\n    PFS, mirror: Inserted\n    PFS, Dish Type: Glass\n    Zoom: 1.00x\n    Eyepiece Ports:\n        Port 1: Off  (Camera)\n        Port 2: On  (Eye)\n\n    LAPP Upper Ports:\n        Port 1: Off  (1)\n        Port 2: On  (2)\n\n    LAPP Lower Ports:\n        Port 1: Off  (H-TIRF Direct XY-F)\n        Port 2: Off  (2)\n        Port 3: On  (3)\n\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    E-TIRF1 Angle: 0.0\n    E-TIRF1 Direction: 0.0\n    NIDAQ, FilterChanger(FilterWheel): 1 (Empty)\n    NIDAQ, Shutter(LUN-F): Closed\n    NIDAQ, Shutter(LUN4): Closed\n    NIDAQ, Shutter(AUX1): Closed\n    NIDAQ, Shutter(EPI): Closed\n    NIDAQ, MultiLaser(LUN-F):\n        Line:1; ExW:405; Power: 34.8; On\n\n    NIDAQ, MultiLaser(LUN4):\n        Line:1; ExW:405; Power: 30.0; Off\n        Line:2; ExW:488; Power: 30.0; Off\n        Line:3; ExW:561; Power: 30.0; On\n        Line:4; ExW:640; Power: 30.0; Off\n\nZ Stack Loop: 5\n- Step: 4 \u00b5m\n- Device: Ti2 ZDrive\ncapturing: Nikon A1 LFOV\n\nsampling:\nlocation:\ndate: 9/22/2068  12:28:28 AM\nconclusion:\ninfo1:\ninfo2:\noptics: Apo LWD 40x WI \u03bbS DIC N2\n</code></pre>"},{"location":"#getting-image-attributes","title":"Getting image attributes","text":"<p>Image attributes dataclass mostly contains information about dimensions of an image like width and height, number of components and number of frames in nd2 file.</p> <p>For all properties and methods of this dataclass see attributes.py.</p> <p>To get image attributes use <code>imageAttributes</code> attribute of <code>Nd2Reader</code> instance created in previous step.</p> example_reader.py<pre><code>attributes = nd2.imageAttributes\n</code></pre> <p>Then you can use following properties to get information about the file:</p> example_reader.py<pre><code>print(f\"Image resolution: {attributes.width} x {attributes.height}\")\nprint(f\"Number of components: {attributes.componentCount}\")\nprint(f\"Number of frames: {attributes.frameCount}\")\nprint(f\"Image size (in bytes): {attributes.imageBytes}\")\nprint(f\"Python data type: {attributes.dtype}\")\n</code></pre> See example output <pre><code>Image resolution: 1024 x 1024\nNumber of components: 2\nNumber of frames: 125\nImage size (in bytes): 8388608\nPython data type: &lt;class 'numpy.float32'&gt;\n</code></pre>"},{"location":"#getting-image-data","title":"Getting image data","text":"<p>This library uses NumPy arrays to store image data found in the <code>.nd2</code> file, if you want to access image data itself, you can do so by using <code>.image()</code> method with index of the image you want to get like this:</p> example_reader.py<pre><code>image = nd2.image(0)        # get first image\nprint(type(image))\nprint(\"Numpy array shape:\", image.shape, \"stored datatype:\", image.dtype)\n</code></pre> See example output <pre><code>&lt;class 'numpy.ndarray'&gt;\nNumpy array shape: (1024, 1024, 2) stored datatype: float32\n</code></pre> <p>If you want to get all images in the <code>.nd2</code> file, use a for loop with <code>frameCount</code> property from image attributes.</p> example_reader.py<pre><code>images = []\nfor i in range(attributes.frameCount):\n    images.append(nd2.image(i))\nprint(f\"Obtained {len(images)} frames.\")\n</code></pre> See example output <pre><code>Obtained 125 frames.\n</code></pre>"},{"location":"#getting-experiment-data","title":"Getting experiment data","text":"<p>Experiments in <code>.nd2</code> files define how image sequences are organized and looped. The most common types of loops include:</p> <ul> <li>Time Loop (<code>timeloop</code>): A sequence of images captured over time.</li> <li>Z-Stack (<code>zstack</code>): Frames stacked along the z-axis, representing different focal planes.</li> <li>Multi-Point (<code>multipoint</code>): Images captured at multiple specified locations (points) with known coordinates.</li> </ul> <p>An image can have no experiment, a single experiment, or a combination of multiple experiments.</p> <p>To obtain data structure with information about used experiments, use <code>experiment</code> property.</p> example_reader.py<pre><code>experiment = nd2.experiment\n</code></pre> <p>Then to see what kind of experiment <code>.nd2</code> file contains, you can iterate over this data structure with a for loop:</p> example_reader.py<pre><code>print(\"Experiment loops in image:\")\nfor e in experiment:\n    print(f\"Experiment name: {e.name}, number of frames: {e.count}\")\n</code></pre> See example output <pre><code>Experiment loops in image:\nExperiment name: Multipoint, number of frames: 25\nExperiment name: Z-Stack, number of frames: 5\n</code></pre> <p>Now if we want to access attributes and methods for specific loop type, we can use .findLevel() method with ExperimentLoopType type as parameter, in this example we search for Z-Stack experiment = use value ExperimentLoopType.eEtZStackLoop.</p> <p>Then we can access data for this experiment through parameters of this experiment, in this example we use attributes and properties of ExperimentZStackLoop.</p> example_reader.py<pre><code>zstack = experiment.findLevel(limnd2.ExperimentLoopType.eEtZStackLoop)\n\nprint(\"Distance between frames:\", zstack.uLoopPars.dZStep, \"\u03bcm\")\nprint(\"Home index:\", zstack.uLoopPars.homeIndex)\nprint(\"Top position:\", zstack.uLoopPars.top, \"\u03bcm\")\nprint(\"Bottom position:\", zstack.uLoopPars.bottom, \"\u03bcm\")\n</code></pre> See example output <pre><code>Distance between frames: 4.0 \u03bcm\nHome index: 2\nTop position: 5.0 \u03bcm\nBottom position: -5.0 \u03bcm\n</code></pre> <p>For all attributes of all experiments type look into experiment.py</p>"},{"location":"#getting-metadata","title":"Getting metadata","text":"<p>Metadata in <code>.nd2</code> file contain a lot of additional data about the image, especially about planes, this information includes:</p> <ul> <li>plane name</li> <li>modality</li> <li>filter path</li> <li>sample settings</li> <li>fluorescent probe</li> <li>much more, see metadata.py for full information about <code>.nd2</code> metadata</li> </ul> <p>To get metadata, use <code>pictureMetadata</code> attribute like this:</p> example_reader.py<pre><code>metadata = nd2.pictureMetadata\n</code></pre> <p>To iterate over planes in the image, you can use <code>.channels()</code> method from the metadata that just were created, then <code>.sampleSettings()</code> method to get sample settings for given plane.</p> <p>With channel and settings stored in separate variables, you can then access selected attributes like this:</p> example_reader.py<pre><code>for channel in metadata.channels:\n    settings = metadata.sampleSettings(channel)\n    print(\"Channel name:\", channel.sDescription)\n    print(\" Modality:\", \" \".join(limnd2.metadata.PicturePlaneModalityFlags.to_str_list(channel.uiModalityMask)))\n    print(\" Emission wavelength:\", channel.emissionWavelengthNm)\n    print(\" Excitation wavelength:\", channel.excitationWavelengthNm)\n\n    print(\" Camera name\", settings.cameraName)\n    print(\" Microscope name\", settings.microscopeName)\n    print(\" Objective magnification\", settings.objectiveMagnification)\n    print()\n</code></pre> See example output <pre><code>Channel name: DETECTOR A\n Modality: Camera AUX\n Emission wavelength: 520.0\n Excitation wavelength: 488.0\n Camera name Nikon A1 LFOV\n Microscope name Ti2 Microscope\n Objective magnification 40.0\n\nChannel name: DETECTOR B\n Modality: Camera AUX\n Emission wavelength: 650.0\n Excitation wavelength: 488.0\n Camera name Nikon A1 LFOV\n Microscope name Ti2 Microscope\n Objective magnification 40.0\n</code></pre>"},{"location":"#getting-other-data","title":"Getting other data","text":"<p>Attributes, experiments, metadata, and image data are the most important parts of an .nd2 file, which is why they were the focus of this guide. The limnd2 module can also access information about binary layers, ROIs, and other data stored in the file. However, at this time, we do not provide a guide on how to read these additional components.</p> <p>If this causes any issues or you need further clarification, please feel free to head over to the Discussion page on our GitHub repository and let us know.</p>"},{"location":"#writing-to-nd2-file","title":"Writing to <code>.nd2</code> file","text":"<p>This package also allows you to write into and create <code>.nd2</code> files using <code>Nd2Writer</code> class, an example of how to do this, you can look into example_writer.py, which will also be described below.</p> <p>In the example below we will create new <code>.nd2</code> file with preset width, height, bits per component, component count and sequence count. Instead of using actual image data we will use NumPy to generate arrays filled with random noise, which we will store in the result file.</p> <p>Here are the settings that will be used to generate image attributes and NumPy arrays with image data.</p> example_writer.py<pre><code>WIDTH = 500\nHEIGHT = 200\nCOMPONENT_COUNT = 2\nBITS = 8\nSEQUENCE_COUNT = 10\n</code></pre> <p>We will also add 2 experiments in the file to showcase how Experiment creation works. We have 10 frames as defined above, we will split them into 5 timeloop indices and 2 Z-stack indices, we will also define step between frames on each axis:</p> example_writer.py<pre><code># timeloop experiment settings\nTIMELOOP_COUNT = 5\nTIMELOOP_STEP = 150\n\n# zstack experiment settings\nZSTACK_COUNT = 2\nZSTACK_STEP = 100\n</code></pre>"},{"location":"#opening-creating-nd2-file-for-writing","title":"Opening / creating <code>.nd2</code> file for writing","text":"<p>With constants defined, we can open <code>.nd2</code> file for reading using Nd2Writer class and <code>with</code> clause for automatic file closure.</p> example_writer.py<pre><code>with limnd2.Nd2Writer(\"outfile.nd2\") as nd2:\n</code></pre> <p>Info</p> <p><code>Nd2Writer</code> can only be created with new, non existing <code>.nd2</code> files.</p> <p>Tip</p> <p>As explained below in writing image data section, image data can only be written after image attributes are set, but if you want to write image data into <code>.nd2</code> file without knowing how many frames there is (for example with continuous writing), you can pass <code>ImageAttributes</code> instance when creating <code>.nd2</code> using custom chunker argument as shown below.</p> <p>Setting <code>ImageAttributes</code> this way will not store them in <code>.nd2</code> file and you still have to store them at some point, however you can do so after you know how many frames there is.</p> Example of using chunker arguments to set image attributes<pre><code>attributes = limnd2.attributes.ImageAttributes.create(\n    width = WIDTH,\n    height = HEIGHT,\n    component_count = COMPONENT_COUNT,\n    bits = BITS,\n    sequence_count = ...  # will be set later\n)\n\nwith limnd2.Nd2Writer(\"outfile.nd2\", chunker_kwargs={\"with_image_attributes\": attributes}) as nd2:\n    # you can now set image data without setting attributes\n</code></pre>"},{"location":"#creating-and-writing-image-attributes","title":"Creating and writing image attributes","text":"<p>Image attributes can be created using <code>ImageAttributes.create()</code> method, we can simply assign those to <code>imageAttributes</code> property of <code>Nd2Writer</code>.</p> example_writer.py<pre><code>attributes = limnd2.attributes.ImageAttributes.create(\n    width = WIDTH,\n    height = HEIGHT,\n    component_count = COMPONENT_COUNT,\n    bits = BITS,\n    sequence_count = SEQUENCE_COUNT\n)\n\nnd2.imageAttributes = attributes\n</code></pre>"},{"location":"#creating-and-writing-image-data","title":"Creating and writing image data","text":"<p>Danger</p> <p>Image data can only be written after image attributes are set either by setting <code>imageAttributes</code> as shown here or by using <code>with_image_attributes</code> as shown in Tip box here.</p> <p>After writing image attributes, we can create random noise data and store them in the <code>.nd2</code> file, for this we will use <code>create_random_noise()</code> function (see <code>example_writer.py</code> for function definition) and send the result array to <code>setImage()</code> method.</p> <p>Important</p> <p>You must manually keep track of index or the image you are storing, also as we with with random noise, the order in which images are inserted does not matter, however the images must be inserted in correct order with respect to used experiments.</p> <p>This is especially important if you are converting multidimensional image sequence to <code>.nd2</code> file.</p> example_writer.py<pre><code>for i in range(SEQUENCE_COUNT):\n    nd2.setImage(i, create_random_noise(WIDTH, HEIGHT, COMPONENT_COUNT, BITS))\n</code></pre>"},{"location":"#creating-and-writing-experiments","title":"Creating and writing experiments","text":"<p>Experiments can be created with <code>ExperimentFactory</code> from <code>experiment_factory</code> module. In this example, we will set count and step for timeloop and zstack experiments and then create the experiment data structure with the <code>createExperiment()</code> method.</p> example_writer.py<pre><code>experiment_factory = limnd2.experiment_factory.ExperimentFactory()\nexperiment_factory.t.count = TIMELOOP_COUNT\nexperiment_factory.t.step = TIMELOOP_STEP\n\nexperiment_factory.z.count = ZSTACK_COUNT\nexperiment_factory.z.step = ZSTACK_STEP\n\nnd2.experiment = experiment_factory.createExperiment()\n</code></pre>"},{"location":"#creating-and-writing-metadata","title":"Creating and writing metadata","text":"<p>Metadata are created in similar way using <code>MetadataFactory</code> from <code>metadata_factory</code> module.</p> <p>On the constructor we provide microscope settings for all planes, then we use <code>addPlane()</code> method to add planes to the metadata with their settings, finally we create metadata with <code>createMetadata()</code> method and assign it to [<code>pictureMetadata</code>] property of [<code>Nd2Writer</code>].</p> example_writer.py<pre><code>metadata_factory = limnd2.metadata_factory.MetadataFactory(\n    zoom_magnification = 200.0,\n    objective_magnification = 1.0,\n    pinhole_diameter = 50,\n    pixel_calibration = 10.0\n)\n\nmetadata_factory.addPlane(\n    name = \"Blue channel\",\n    modality = \"Confocal, Fluo\",\n    color = \"blue\"\n)\n\nmetadata_factory.addPlane(\n    name = \"Red channel\",\n    modality = \"Confocal, Fluo\",\n    color = \"red\"\n)\n\nnd2.pictureMetadata = metadata_factory.createMetadata()\n</code></pre>"},{"location":"#saving-file","title":"Saving file","text":"<p>As we used <code>with</code> context manager, file is automatically saved and closed, if you did not use context manager, you need to manually call <code>.finalize()</code> method from <code>Nd2Writer</code> instance.</p> <p>With this done, you can now run the Python script and open the file in NIS Elements.</p>"},{"location":"#full-api-reference","title":"Full API reference","text":"<p>Here are the most important files in this library and an overview of what they contain:</p> <ul> <li>nd2.py - contains classes for opening ND2 files for reading and writing</li> <li>attributes.py - contains data structures about image attributes (width, height, component count, sequence count, ...)</li> <li>experiment.py - contains data structures about experiment loops (timeloop, z-stack, multipoint, ...)<ul> <li>experiment_factory.py - contains helpers for creating experiment data structure</li> </ul> </li> <li>metadata.py - contains data structures about image attributes (width, height, component count, sequence count, ...)</li> </ul> <p>Compatibility layer:</p> <ul> <li>nd2file.py - serves as a wrapper around limnd2 library to provide same interface to nd2 library by Talley Lambert</li> </ul>"},{"location":"#feedback","title":"Feedback","text":"<p>Did you find a bug? Do you have a question about this package or an idea for improvement? Join the discussion here.</p>"},{"location":"attributes/","title":"Attributes module","text":""},{"location":"attributes/#limnd2.attributes.ImageAttributes","title":"ImageAttributes  <code>dataclass</code>","text":"<pre><code>ImageAttributes(*, uiWidth: int = LV_field(0, UINT32), uiWidthBytes: int = LV_field(0, UINT32), uiHeight: int = LV_field(0, UINT32), uiComp: int = LV_field(0, UINT32), uiBpcInMemory: int = LV_field(0, INT32), uiBpcSignificant: int = LV_field(0, INT32), uiSequenceCount: int = LV_field(0, UINT32), uiTileWidth: int = LV_field(0, UINT32), uiTileHeight: int = LV_field(0, UINT32), eCompression: ImageAttributesCompression = LV_field(ictNone, INT32), dCompressionParam: float = LV_field(0.0, DOUBLE), ePixelType: ImageAttributesPixelType = LV_field(pxtUnsigned, INT32), uiVirtualComponents: int = LV_field(0, UINT32))\n</code></pre> <p>Dataclass for ND2 Image attributes chunk, stores mostly information about image width, height, number of components and bit depth of each pixel, as well as information about compression and total number of images.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.componentBytes","title":"componentBytes  <code>property</code>","text":"<pre><code>componentBytes: int\n</code></pre> <p>Size of component in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.componentCount","title":"componentCount  <code>property</code>","text":"<pre><code>componentCount: int\n</code></pre> <p>Returns number of components in the image.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: NumpyDTypeLike\n</code></pre> <p>Returns numpy datatype used for storing image data in Python.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.frameCount","title":"frameCount  <code>property</code>","text":"<pre><code>frameCount: int\n</code></pre> <p>Returns number of frames in the ND2 file.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Returns height of the image in pixels.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.imageBytes","title":"imageBytes  <code>property</code>","text":"<pre><code>imageBytes: int\n</code></pre> <p>Total size of the image in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.lowerPowSizeList","title":"lowerPowSizeList  <code>property</code>","text":"<pre><code>lowerPowSizeList: list[int]\n</code></pre> <p>Returns list of powers of 2 between ND2_MIN_DOWNSAMPLED_SIZE and image resolution.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.pixelBytes","title":"pixelBytes  <code>property</code>","text":"<pre><code>pixelBytes: int\n</code></pre> <p>Size of pixel in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.powSize","title":"powSize  <code>property</code>","text":"<pre><code>powSize: int\n</code></pre> <p>Returns next power of 2 for bigger dimension.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.powSizeBase","title":"powSizeBase  <code>property</code>","text":"<pre><code>powSizeBase: int\n</code></pre> <p>Returns exponent used in powSize() function.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.safe_dtype","title":"safe_dtype  <code>property</code>","text":"<pre><code>safe_dtype: NumpyDTypeLike\n</code></pre> <p>Returns numpy datatype that will always be big enough to fit pixel component data.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre> <p>Returns shape of the image which can be used with in array (height_pixels, width_pixels, component_count)</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.strides","title":"strides  <code>property</code>","text":"<pre><code>strides: tuple[int, int, int]\n</code></pre> <p>Returns the strides of the image which can be used in numpy array</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>Returns width of the image in pixels.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.widthBytes","title":"widthBytes  <code>property</code>","text":"<pre><code>widthBytes: int\n</code></pre> <p>Size of image row in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.calcWidthBytes","title":"calcWidthBytes  <code>staticmethod</code>","text":"<pre><code>calcWidthBytes(width: int, bits: int, comps: int) -&gt; int\n</code></pre> <p>Calculates number of bytes per single image row.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.create","title":"create  <code>staticmethod</code>","text":"<pre><code>create(height: int, width: int, component_count: int, bits: int, sequence_count: int) -&gt; ImageAttributes\n</code></pre> <p>Warning</p> <p>This function is used for creating new ImageAttributes instance, usually for creating new .nd2 files with Nd2Writer class. Do not use this function if you only read <code>.nd2</code> file.</p> <p>Create ImageAttributes instance from following arguments (all must be passed as named arguments)</p> PARAMETER DESCRIPTION <code>height</code> <p>height in pixels</p> <p> TYPE: <code>int</code> </p> <code>width</code> <p>width in pixels</p> <p> TYPE: <code>int</code> </p> <code>component_count</code> <p>number of components</p> <p> TYPE: <code>int</code> </p> <code>bits</code> <p>number of bits per pixel component</p> <p> TYPE: <code>int</code> </p> <code>sequence_count</code> <p>total number of frames in ND2 file (product of size of each dimension)</p> <p> TYPE: <code>int</code> </p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.from_lv","title":"from_lv  <code>staticmethod</code>","text":"<pre><code>from_lv(data: bytes | memoryview) -&gt; ImageAttributes\n</code></pre> <p>Decodes ImageAttributes from ND2 lite variant chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.from_var","title":"from_var  <code>staticmethod</code>","text":"<pre><code>from_var(data: bytes | memoryview) -&gt; ImageAttributes\n</code></pre> <p>Decodes ImageAttributes from ND2 XML chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.makeDownsampled","title":"makeDownsampled","text":"<pre><code>makeDownsampled(downsize: int | None = None) -&gt; ImageAttributes\n</code></pre> <p>Returns ImageAttributes for downsampled image using power of 2 image size.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.makeDownsampledFromPowBase","title":"makeDownsampledFromPowBase","text":"<pre><code>makeDownsampledFromPowBase(powBase: int) -&gt; ImageAttributes\n</code></pre> <p>Returns ImageAttributes for downsampled image using power of 2 exponent.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.to_lv","title":"to_lv","text":"<pre><code>to_lv() -&gt; bytes\n</code></pre> <p>Encodes ImageAttributes to ND2 lite variant chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributesCompression","title":"ImageAttributesCompression","text":"<p>Enum for image compression.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributesPixelType","title":"ImageAttributesPixelType","text":"<p>Enum for pixel type.</p>"},{"location":"cli_convert_image/","title":"Convert image to ND2 file","text":"<p>Following command line tool allows you to convert single image into ND2 file:</p> <pre><code>limnd2-convert-file-to-nd2 &lt;arguments&gt;\n</code></pre>"},{"location":"cli_convert_image/#arguments","title":"Arguments","text":"<p>Important</p> <p>Arguments highlighted in bold (<code>input</code>) are required.</p> <ul> <li> <p><code>input</code></p> <p>Input file or directory to be converted.</p> </li> <li> <p><code>output</code></p> <p>File name of the converted <code>.nd2</code> file. If not specified, script will use same name as input file with <code>.nd2</code> extension.</p> </li> <li> <p><code>-f</code></p> <p>Force overwrite of the output file if it already exists.</p> </li> <li> <p><code>--unknown_dimension &lt;dimension&gt;</code></p> <p>Specify which dimension to use if there is an unknown dimension in the input file (e.g., multipage TIFF). Choices: <code>multipoint</code>, <code>timeloop</code>, <code>zstack</code>. Default: <code>multipoint</code>.</p> </li> </ul>"},{"location":"cli_convert_image/#examples","title":"Examples","text":"<p>Here are some example usages of the <code>limnd2-convert-file-to-nd2</code> command:</p> Convert a single image to ND2 <pre><code>limnd2-convert-file-to-nd2 ./image.tif\n</code></pre> Convert a single image and specify the output file name <pre><code>limnd2-convert-file-to-nd2 ./images/image.png ./output/output.nd2\n</code></pre> Convert an image and force overwrite if output exists <pre><code>limnd2-convert-file-to-nd2 ./images/image.tif -f\n</code></pre> Convert an image and specify how to handle unknown dimensions (for example multipage TIFF) <pre><code>limnd2-convert-file-to-nd2 ./images/image.tif --unknown_dimension zstack\n</code></pre>"},{"location":"cli_convert_sequence/","title":"Convert sequence of images to ND2 file","text":"<p>Following script can be used to convert a sequence of images into a single ND2 file or generate a JSON description of the sequence. The script is designed to work with various image formats and allows for flexible pattern matching to identify the relevant files.</p> <pre><code>limnd2-convert-sequence-to-nd2 &lt;arguments&gt;\n</code></pre> <p>Warning</p> <p>JSON describe the sequence is limited and does not support multidimensional files like multipage TIFFs or OME TIFFs.</p>"},{"location":"cli_convert_sequence/#arguments","title":"Arguments","text":"<p>This script uses multiple required and optional arguments to specify the input folder, file patterns, output file names, and metadata settings. The arguments are organized into several categories for clarity. See provided examples to understand how to use them.</p> <p>Important</p> <p>Arguments highlighted in bold (<code>folder</code> and <code>regexp</code>) are required. You also need to specify either <code>-n</code> or <code>-j</code> argument.</p>"},{"location":"cli_convert_sequence/#input-arguments","title":"Input arguments","text":"<ul> <li> <p><code>folder</code></p> <p>Path to the folder containing the image sequence files.</p> </li> <li> <p><code>--extension &lt;extension&gt;</code></p> <p>File extension to match (if not provided, detected from the regular expression).</p> </li> </ul>"},{"location":"cli_convert_sequence/#pattern-matching-arguments","title":"Pattern matching arguments","text":"<ul> <li> <p><code>regexp</code></p> <p>Regular expression with capture groups to match filenames.</p> </li> <li> <p><code>-s</code>, <code>--simple_regexp</code></p> <p>Use a simplified glob-like patterns for matching dimensions.</p> Pattern Match Description <code>*</code> Any number of characters <code>???</code> Matches exactly N characters ( depends on <code>?</code> count) </li> </ul>"},{"location":"cli_convert_sequence/#dimension-arguments","title":"Dimension arguments","text":"<ul> <li> <p><code>-mx &lt;index&gt;</code>, <code>--multipoint_x &lt;index&gt;</code></p> <p>Specify the capture group index for the multipoint x-axis.</p> </li> <li> <p><code>-my &lt;index&gt;</code>, <code>--multipoint_y &lt;index&gt;</code></p> <p>Specify the capture group index for the multipoint y-axis.</p> </li> <li> <p><code>-m &lt;index&gt;</code>, <code>--multipoint &lt;index&gt;</code></p> <p>Specify the capture group index for multipoint.</p> </li> <li> <p><code>-z &lt;index&gt;</code>, <code>--zstack &lt;index&gt;</code></p> <p>Specify the capture group index for Z-stack.</p> </li> <li> <p><code>-t &lt;index&gt;</code>, <code>--timeloop &lt;index&gt;</code></p> <p>Specify the capture group index for time index.</p> </li> <li> <p><code>-c &lt;index&gt;</code>, <code>--channel &lt;index&gt;</code></p> <p>Specify the capture group index for channels.</p> </li> <li> <p><code>--extra-dimension &lt;dimension&gt;</code></p> <p>Specify how to handle additional dimension if it exists, for example in multipage tiff files. Choose from: <code>timeloop</code>, <code>zstack</code>, <code>multipoint</code>, or <code>channel</code>.</p> </li> </ul> <p>Warning</p> <p>If you use <code>-mx</code> or <code>-my</code> arguments, you can not use <code>-m</code> argument anymore.</p> <p>Warning</p> <p>Dimension indexes are 1-based, meaning the first capture group is index 1.</p> See example how to match the capture groups in filename <p>Suppose you have the following files in your folder: <pre><code>tiff_c1_z1.tif\ntiff_c1_z2.tif\ntiff_c1_z3.tif\ntiff_c2_z1.tif\ntiff_c2_z2.tif\ntiff_c2_z3.tif\n</code></pre></p> <p>You can convert them into an ND2 file using:</p> <pre><code>limnd2-convert-sequence-to-nd2 ./images \"tiff_c(\\d+)_z(\\d+).tif\" -c 1 -z 2\n</code></pre> <p>Or if you enable simplified regular expression using <code>-s</code> or <code>--simple_regexp</code> argument:</p> <pre><code>limnd2-convert-sequence-to-nd2 ./images \"tiff_c*_z*.tif\" -s -c 1 -z 2\n</code></pre> <ul> <li><code>-c 1</code> specifies that the first capture group (after <code>c</code>) is the channel index.</li> <li><code>-z 2</code> specifies that the second capture group (after <code>z</code>) is the Z-stack index.</li> </ul>"},{"location":"cli_convert_sequence/#output-arguments","title":"Output arguments","text":"<ul> <li> <p><code>-n &lt;output_nd2_filename&gt;</code>, <code>--nd2 &lt;output_nd2_filename&gt;</code> :</p> <p>Convert sequence to specified ND2 file.</p> </li> <li> <p><code>-j &lt;output_json_filename&gt;</code> or <code>--json &lt;output_json_filename&gt;</code></p> <p>Output sequence as a specified JSON description file (limited support; does not support multidimensional files like multipage TIFFs or OME TIFFs).</p> </li> <li> <p><code>-o &lt;output_directory&gt;</code>, <code>--output_dir &lt;output_directory&gt;</code></p> <p>Specify output directory for the ND2 / JSON file (same as input folder by default).</p> </li> </ul> <p>Warning</p> <p>You must use either <code>-n</code> or <code>-j</code> argument.</p> <p>Danger</p> <p>If output file already exists, it will be overwritten without warning.</p> See example on how to specify the output <p>Following example shows how to convert the sequence of images into a ND2 file and save it in a different directory: <pre><code>limnd2-convert-sequence-to-nd2 ./images \"tiff_c*_z*.tif\" -s -c 1 -z 2 -n output.nd2 -o ./output\n</code></pre></p>"},{"location":"cli_convert_sequence/#experiment-arguments","title":"Experiment arguments","text":"<ul> <li> <p><code>-zstep &lt;value&gt;</code>, <code>--zstack_step &lt;value&gt;</code></p> <p>Z-stack step size in micrometers (default: 100).</p> </li> <li> <p><code>-tstep &lt;value&gt;</code>, <code>--timeloop_step &lt;value&gt;</code></p> <p>Time step in milliseconds (default: 100).</p> </li> </ul>"},{"location":"cli_convert_sequence/#metadata-arguments","title":"Metadata arguments","text":"<ul> <li> <p><code>--channel-setting &lt;channel_string&gt;</code></p> <p>Specify channel settings as <code>[original_name|new_name|modality|ex|em|color]</code>.</p> <p>Warning</p> <p>You must use <code>|</code> to separate the values in the channel string, you can not use <code>|</code> anywhere else in the command.</p> Setting Description original_name Original channel name in the image file (must match exactly). new_name New name to assign to the channel in the ND2 file. modality Imaging modality (e.g., fluorescence, brightfield). ex Excitation wavelength (in nm). em Emission wavelength (in nm). color Channel color (hex code or color name, e.g., <code>#FF0000</code> or <code>red</code>). </li> <li> <p><code>--pixel_calibration &lt;value&gt;</code></p> <p>Set pixel calibration value (in micrometers per pixel). Default is <code>0.0</code>.</p> </li> <li> <p><code>--ms-objective_magnification &lt;value&gt;</code></p> <p>Microscope objective magnification. Default is <code>-1.0</code> (unspecified).</p> </li> <li> <p><code>--ms-objective_numerical_aperture &lt;value&gt;</code></p> <p>Microscope objective numerical aperture. Default is <code>-1.0</code> (unspecified).</p> </li> <li> <p><code>--ms-zoom_magnification &lt;value&gt;</code></p> <p>Microscope zoom magnification. Default is <code>-1.0</code> (unspecified).</p> </li> <li> <p><code>--ms-immersion_refractive_index &lt;value&gt;</code></p> <p>Microscope immersion medium refractive index. Default is <code>-1.0</code> (unspecified).</p> </li> <li> <p><code>--ms-pinhole_diameter &lt;value&gt;</code></p> <p>Microscope pinhole diameter. Default is <code>-1.0</code> (unspecified).</p> </li> </ul>"},{"location":"cli_convert_sequence/#other-arguments","title":"Other arguments","text":"<ul> <li> <p><code>--multiprocessing</code></p> <p>Use multiple threads to write the ND2 file.</p> </li> </ul>"},{"location":"cli_convert_sequence/#example-usage","title":"Example usage","text":"<p>Below are some example commands for <code>limnd2-convert-sequence-to-nd2</code>. A</p> Basic Z-stack and Time-lapse conversion <pre><code>limnd2-convert-sequence-to-nd2 ./tiffs \"exportz(\\d+)t(\\d+).tif\"\n    --zstack 1 --timeloop 2 -tstep 120 -zstep 130 -n test.nd2 -o ./tiffs\n</code></pre> <ul> <li><code>./tiffs</code>: Input folder containing the TIFF files.</li> <li><code>\"exportz(\\d+)t(\\d+).tif\"</code>: Regular expression to match the filenames.</li> <li><code>--zstack 1</code> Zstack is described in first capture group.</li> <li><code>--timeloop 2</code> Timeloop is described in second capture group.</li> <li><code>-zstep 130</code> Distance (in \u03bcm) between Z planes.</li> <li><code>-tstep 120</code> Time interval (in miliseconds) between two frames.</li> </ul> Using simplified regular expression, specifying output file and directory <pre><code>limnd2-convert-sequence-to-nd2 ./tiffs \"exportz*t*.tif\"\n    -s --zstack 1 --timeloop 2 -n result.nd2\n</code></pre> <ul> <li><code>-s result.nd2</code> Use simplified regular expression.</li> <li><code>-n result.nd2</code>: Name of the output ND2 file.</li> <li><code>-o ./output</code>: Output directory for the ND2 file.</li> </ul> Pixel calibration and microscope settings <pre><code>limnd2-convert-sequence-to-nd2 ./tiffs \"exportz(\\d+)t(\\d+).tif\"\n    --zstack 1 --timeloop 2 --pixel_calibration 65 --ms-objective_magnification 40\n    --ms-objective_numerical_aperture 1.3 --ms-immersion_refractive_index 1.5\n</code></pre> <ul> <li><code>--pixel_calibration 65</code>: Pixel size in nanometers.</li> <li><code>--ms-objective_magnification 40</code>: Microscope objective magnification.</li> <li><code>--ms-objective_numerical_aperture 1.3</code>: Numerical aperture of the objective.</li> <li><code>--ms-immersion_refractive_index 1.5</code>: Immersion medium refractive index.</li> </ul> Assigning channels and custom channel settings <p>Suppose you have the following files in your folder: <pre><code>exportz1c_dapi.tif\nexportz1c_dia.tif\nexportz2c_dapi.tif\nexportz2c_dia.tif\n...\n</code></pre></p> <pre><code>limnd2-convert-sequence-to-nd2 ./tiffs \"exportz(\\d+)c_(.+?).tif\"\n    --zstack 1 --channel 2 -n test2.nd2 -o ./tiffs --multiprocessing\n    --channel-setting dapi|DAPI Channel|Wide-field|620|750|#FF0000\n    --channel-setting dia|DIA Channel|DIC|495|570|Green\n</code></pre> <ul> <li><code>--channel 2</code>: Second capture group is the channel dimension.</li> </ul> <p>Following arguments set channel information:</p> <ul> <li><code>--channel-setting dapi|DAPI Channel|Wide-field|620|750|#FF0000</code></li> <li><code>--channel-setting dia|DIA Channel|DIC|495|570|Green</code></li> </ul> Attribute Channel 1 Channel 2 Channel name in filename dapi dia Name DAPI Channel DIA Channel Type Wide-field DIC Excitation (nm) 620 495 Emission (nm) 750 570 Color #FF0000 (red) Green"},{"location":"cli_index/","title":"Index ND2 files","text":"<p>Following command line tool allows you to index ND2 files is specified directory and extract basic metadata:</p> <pre><code>limnd2-index &lt;arguments&gt;\n</code></pre> <p>Script also allows you to filter, sort, and format the output. The output can be formatted as a table, CSV, or JSON.</p> <p>As an example, the following command will index all ND2 files in the current directory and output the results as a table, filter only specific columns, and select images with resolution greater than 1000 pixels:</p> <pre><code>limnd2-index.exe . -i Name,Size,Experiment,Resolution -F \"int(Resolution.split('x')[0]) &gt; 1000\"\n</code></pre> <p>Output:</p> <pre><code>+-----------------------------+----------+----------------+--------------+\n| Name                        | Size     | Experiment     | Resolution   |\n+-----------------------------+----------+----------------+--------------+\n| 1 dfm tub pc.nd2            | 164.1 MB | Z (54)         | 1024 x 512   |\n| convallaria_FLIM.nd2        | 6.3 GB   | XY (25), Z (5) | 1024 x 1024  |\n| golgi01.nd2                 | 60.4 MB  | Z (24)         | 1280 x 1024  |\n| underwater_bmx.nd2          | 2.5 MB   |                | 1076 x 773   |\n+-----------------------------+----------+----------------+--------------+\n</code></pre>"},{"location":"cli_index/#arguments","title":"Arguments","text":"<p>Important</p> <p>Arguments highlighted in bold (<code>paths</code>) are required.</p> <ul> <li> <p><code>paths</code></p> <p>One or more paths to ND2 files or directories containing ND2 files. Required.</p> </li> <li> <p><code>--recurse</code>, <code>-r</code></p> <p>Recursively search directories for ND2 files. Optional.</p> </li> <li> <p><code>--glob-pattern &lt;pattern&gt;</code>, <code>-g &lt;pattern&gt;</code></p> <p>Glob pattern to search for ND2 files. Default: <code>*.nd2</code>. Optional.</p> </li> <li> <p><code>--sort-by &lt;column&gt;</code>, <code>-s &lt;column&gt;</code></p> <p>Column to sort by. Choices are valid column names, or append a hyphen (<code>-</code>) for reverse order. If not specified, order is not guaranteed. Optional.</p> </li> <li> <p><code>--format &lt;format&gt;</code>, <code>-f &lt;format&gt;</code></p> <p>Output format. Choices: <code>table</code>, <code>csv</code>, <code>json</code>. Default: <code>table</code> (if rich is available), otherwise <code>json</code>. Optional.</p> </li> <li> <p><code>--include &lt;list&gt;</code>, <code>-i &lt;list&gt;</code></p> <p>Comma-separated list of columns to include in the output. Optional.</p> </li> <li> <p><code>--exclude &lt;list&gt;</code>, <code>-e &lt;list&gt;</code></p> <p>Comma-separated list of columns to exclude from the output. Optional.</p> </li> <li> <p><code>--no-header</code></p> <p>Do not write the CSV header. Optional.</p> </li> <li> <p><code>--filter &lt;expression&gt;</code>, <code>-F &lt;expression&gt;</code></p> <p>Filter the output using a Python expression (string) that evaluates to True or False for each row. Can be used multiple times. Example: <code>\"Frames &gt; 50 and 'T' in Experiment\"</code>. Optional.</p> </li> </ul>"},{"location":"cli_index/#valid-column-names","title":"Valid column names","text":"<p>The following columns are available for output, filtering, and sorting.</p> Column Data Type Description <code>Path</code> <code>str</code> Full file path <code>Name</code> <code>str</code> File name <code>Version</code> <code>str</code> ND2 file version <code>Size</code> <code>str</code> File size <code>Modified</code> <code>str</code> Last modified timestamp <code>Experiment</code> <code>str</code> Experiment names and frame count <code>Frames</code> <code>int</code> Total number of frames <code>Dtype</code> <code>str</code> Data type <code>Bits</code> <code>int</code> Bit depth <code>Resolution</code> <code>str</code> Image resolution <code>Channels</code> <code>int</code> Number of channels <code>Binary</code> <code>str</code> Binary metadata <code>Software</code> <code>str</code> Acquisition software <code>Grabber</code> <code>str</code> Acquisition hardware/grabber"},{"location":"cli_index/#examples","title":"Examples","text":"<p>Here are some example usages of the <code>limnd2-index</code> command:</p> Index all ND2 files in a directory <pre><code>limnd2-index ./data\n</code></pre> Index ND2 files recursively in subdirectories <pre><code>limnd2-index ./data --recurse\n</code></pre> Index ND2 files matching a glob pattern <pre><code>limnd2-index ./data --glob-pattern '*.nd2'\n</code></pre> Sort output by acquisition date <pre><code>limnd2-index ./data --sort-by Frames\n</code></pre> Output results as CSV and include only specific columns <pre><code>limnd2-index ./data --format csv --include Name,Experiment\n</code></pre> Filter files <pre><code>limnd2-index ./data --filter \"Frames &gt; 50 and 'T' in Experiment\"\n</code></pre>"},{"location":"convert_image/","title":"Convert image to ND2 format","text":"<p>Functions for converting images are not part of the base <code>limnd2</code> namespace, but are instead accessible through the <code>limnd2.tools</code> namespace.</p> <p>In order to use functions and classes described on this page, import them like this:</p> <pre><code>from limnd2.tools import convert_file_to_nd2,\\\n    convert_file_to_nd2_args, convert_file_to_nd2_cli\n</code></pre>"},{"location":"convert_image/#summary","title":"Summary","text":"<ul> <li>convert_file_to_nd2:  Convert an image to ND2.</li> <li>convert_file_to_nd2_cli:  Convert an image to ND2 format with CLI arguments (for CLI usage).</li> <li>convert_file_to_nd2_args:  Convert an image ND2 format with CLI arguments (for usage in Python scripts).</li> </ul>"},{"location":"convert_image/#function-documentation","title":"Function documentation","text":""},{"location":"convert_image/#limnd2.tools.conversion.LimConvertFile.convert_file_to_nd2","title":"convert_file_to_nd2","text":"<pre><code>convert_file_to_nd2(input_path: str | Path | LimImageSource, output_path: str | Path, extra_dim_type: str = 'multipoint')\n</code></pre> <p>Converts an input file or LimImageSource to ND2 format and writes it to the specified output path. You can specify the extra dimension type for parsing, such as <code>\"multipoint\"</code>, <code>\"timeloop\"</code>, or <code>\"zstack\"</code>, this is useful for multipage TIFF files.</p> PARAMETER DESCRIPTION <code>input_path</code> <p>Path to the input file or a LimImageSource object to be converted.</p> <p> TYPE: <code>str | Path | LimImageSource</code> </p> <code>output_path</code> <p>Path where the resulting ND2 file will be saved, if not provided, the input file name will be used with .nd2 extension.</p> <p> TYPE: <code>str | Path</code> </p> <code>extra_dim_type</code> <p>Type of extra dimension to parse, for example with multipage TIFF file, must be one of <code>[\"multipoint\", \"timeloop\", \"zstack\"]</code>. (default is \"multipoint\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'multipoint'</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the written ND2 file.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the input_path is not a valid file path or LimImageSource object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; convert_file_to_nd2(\"input.jpeg\", Path(\"output.nd2\"))\n&gt;&gt;&gt; convert_file_to_nd2(\"image.png\", \"converted_output.nd2\", extra_dim_type=\"timeloop\")\n</code></pre>"},{"location":"convert_image/#limnd2.tools.conversion.LimConvertFile.convert_file_to_nd2_cli","title":"convert_file_to_nd2_cli","text":"<pre><code>convert_file_to_nd2_cli(args: list[str] | None = None)\n</code></pre> <p>Converts a file to ND2 format using command line arguments for usage in CLI (returns exit code).</p> <p>Command line arguments should be provided as a list of strings. The specific arguments and their usage are described in the CLI version of this tool: CLI Convert image tool</p> PARAMETER DESCRIPTION <code>args</code> <p>List of command line arguments. If None, uses sys.argv.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Exits the program with exit code 0 if successful, or 1 if an error occurred.</p>"},{"location":"convert_image/#limnd2.tools.conversion.LimConvertFile.convert_file_to_nd2_args","title":"convert_file_to_nd2_args","text":"<pre><code>convert_file_to_nd2_args(args: list[str] | None = None)\n</code></pre> <p>Converts a file to ND2 format using command line arguments for usage in Python (returns the output path).</p> <p>Command line arguments should be provided as a list of strings. The specific arguments and their usage are described in the CLI version of this tool: CLI Convert image tool</p> PARAMETER DESCRIPTION <code>args</code> <p>List of command line arguments. If None, uses sys.argv.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the converted ND2 file.</p>"},{"location":"convert_image_source/","title":"LimImageSource class","text":"<p>This class is mainly used for converting images of different formats to ND2 format. It serves as a locator for specific image frame (just filepath for most image formats, filepath + IDF for TIFF files).</p> <p>This class is not a part of the base <code>limnd2</code> namespace, but is instead accessible through the <code>limnd2.tools</code> namespace like this:</p> <pre><code>from limnd2.tools import LimImageSource\n</code></pre>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource","title":"LimImageSource","text":"<pre><code>LimImageSource(filename: str | Path)\n</code></pre> <p>Abstract class for reading images of different formats. Currently supported formats are:</p> <ul> <li>TIFF and its subformats (<code>.ome.tiff</code>, <code>.btf</code>, <code>.tif</code>, <code>.tiff</code>)</li> <li>PNG (<code>.png</code>)</li> <li>JPEG (<code>.jpg</code>, <code>.jpeg</code>)</li> </ul> <p>This class provides a common interface for reading images and converting them to ND2 format, as well as for extracting additional information from the images.</p> <p>Warning</p> <p>This class is not intended to be used directly, but rather as a base class for specific image source classes. In order to correctly create object of this class, use the <code>open()</code> method, which will automatically detect the file type and create the appropriate LimImageSource object.</p>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource.is_rgb","title":"is_rgb  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_rgb: bool\n</code></pre> <p>Check if the image is RGB.</p>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource.get_file_dimensions","title":"get_file_dimensions","text":"<pre><code>get_file_dimensions() -&gt; dict[str, int]\n</code></pre> <p>Return dimensions inside just the file. In OME TIFF file, this will return OME dimensions within file. In multipage file, this will return unknown dimension in the file. In other file formats, this will return empty dictionary.</p>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource.nd2_attributes","title":"nd2_attributes  <code>abstractmethod</code>","text":"<pre><code>nd2_attributes(*, sequence_count=1) -&gt; ImageAttributes\n</code></pre> <p>Get ND2 attributes from the image source.</p> <p>Note</p> <p>If you use those attributes when converting file sequence to ND2, you need to replace the sequence count with the number of files in the sequence. You must also set component count if you use convert multichannel ND2 image.</p>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource.open","title":"open  <code>staticmethod</code>","text":"<pre><code>open(filename: str | Path) -&gt; LimImageSource\n</code></pre> <p>Create a LimImageSource object from a filename. This will automatically detect the file type and create the appropriate LimImageSource object (<code>LimImageSourceTiff</code>, <code>LimImageSourcePng</code>, ...).</p>"},{"location":"convert_image_source/#limnd2.tools.conversion.LimImageSource.LimImageSource.read","title":"read  <code>abstractmethod</code>","text":"<pre><code>read() -&gt; ndarray\n</code></pre> <p>Read the image into numpy array writeable by limnd2 library.</p>"},{"location":"convert_sequence/","title":"Convert image sequence to ND2 format","text":"<p>Functions for converting image sequences are not part of the base <code>limnd2</code> namespace, but are instead accessible through the <code>limnd2.tools</code> namespace.</p> <p>In order to use functions and classes described on this page, import them like this:</p> <pre><code>from limnd2.tools import convert_sequence_to_nd2,\\\n    convert_sequence_to_nd2_args, convert_sequence_to_nd2_cli\n</code></pre>"},{"location":"convert_sequence/#summary","title":"Summary","text":"<ul> <li>convert_sequence_to_nd2:  Convert a sequence of images to ND2 format.</li> <li>convert_sequence_to_nd2_cli:  Convert a sequence of images to ND2 format with CLI arguments (for CLI usage).</li> <li>convert_sequence_to_nd2_args:  Convert a sequence of images to ND2 format with CLI arguments (for usage in Python scripts).</li> </ul>"},{"location":"convert_sequence/#examples","title":"Examples","text":"<p>Since converting image sequences is pretty advanced task and requires correct order of images, and correctly set attributes and metadata, we prepared a few examples that showcase how to use the <code>convert_sequence_to_nd2</code> function to create one dimensional, multi-dimensional and even multi-channel ND2 files.</p> <p>To see the examples, please check out the convert_to_nd2_examples folder in the <code>limnd2</code> repository on GitHub.</p>"},{"location":"convert_sequence/#function-documentation","title":"Function documentation","text":""},{"location":"convert_sequence/#limnd2.tools.conversion.LimConvertSequence.convert_sequence_to_nd2","title":"convert_sequence_to_nd2","text":"<pre><code>convert_sequence_to_nd2(input_data: list[list[LimImageSource]] | list[tuple[LimImageSource]] | list[list[str | Path]] | list[tuple[str | Path]] | list[LimImageSource] | list[str | Path], output_path: Path | str, attributes: ImageAttributes | None = None, experiment: ExperimentLevel | str | None = None, metadata: PictureMetadata | None = None) -&gt; bool\n</code></pre> <p>Convert a sequence of images to ND2 format. This function takes a sequence of images (either as file paths or <code>LimImageSource</code>  objects) and converts them to ND2 file. User can also provide custom attributes, experiment, and metadata for the ND2 file, if they are not provided, default values will be used.</p> PARAMETER DESCRIPTION <code>input_data</code> <p>1D or 2D list of file paths or <code>LimImageSource</code> objects representing the images to be converted. If the input list is one dimensional, each image will be treated as a separate frame, if the input list is two dimensional, each sublist is treated as several channels in the same frame.</p> <p> TYPE: <code>str | Path | LimImageSource</code> </p> <code>output_path</code> <p>Path where the resulting ND2 file will be saved.</p> <p> TYPE: <code>str | Path</code> </p> <code>attributes</code> <p>ND2 file atributes</p> <p>Warning</p> <p>ND2 attributes must be correctly set, or the data may be shown incorrectly when viewing the ND2 file. If you are unsure about the attributes, omit the argument and they will be calculated automatically based on the input data.</p> <p> TYPE: <code>ImageAttributes</code> DEFAULT: <code>None</code> </p> <code>experiment</code> <p>Experiment level for the ND2 file or a string describing what type of experiment to create <code>[\"timeloop\", \"zstack\", \"multipoint\"]</code>.</p> <p>Warning</p> <p>ND2 experiment must also be correctly set (to match dimensions of the input data), if the experiment is omitted, the function will creare multipoint experiment with the number of points equal to the number of frames in the input data.</p> <p>It is also important that the files are ordered correctly with respect to the set experiment. In ideal case, files will be ordered by timeloop first, then multipoint, then zstack.</p> <p> TYPE: <code>ExperimentLevel | str</code> DEFAULT: <code>None</code> </p> <code>metadata</code> <p>Metadata for the ND2 file. If not provided, default metadata will be used (those are calulated based on number of channels).</p> <p>Warning</p> <p>ND2 metadata must also be correctly set, number of channels in the metadata must match the number of channels in the input data.</p> <p> TYPE: <code>PictureMetadata</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the written ND2 file.</p>"},{"location":"convert_sequence/#limnd2.tools.conversion.LimConvertSequence.convert_sequence_to_nd2_cli","title":"convert_sequence_to_nd2_cli","text":"<pre><code>convert_sequence_to_nd2_cli(args: list[str] | None = None) -&gt; int\n</code></pre> <p>Converts a sequence of images to ND2 file using command line arguments for usage in CLI (returns exit code).</p> <p>Command line arguments should be provided as a list of strings. The specific arguments and their usage are described in the CLI script that uses this function: CLI Convert image tool</p> PARAMETER DESCRIPTION <code>args</code> <p>List of command line arguments. If None, uses sys.argv.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Exits the program with exit code 0 if successful, or 1 if an error occurred.</p>"},{"location":"convert_sequence/#limnd2.tools.conversion.LimConvertSequence.convert_sequence_to_nd2_args","title":"convert_sequence_to_nd2_args","text":"<pre><code>convert_sequence_to_nd2_args(args: list[str] | None = None) -&gt; Path\n</code></pre> <p>Converts a sequence of images to ND2 file using command line arguments for usage in Python scripts (returns path to the file).</p> <p>Command line arguments should be provided as a list of strings. The specific arguments and their usage are described in the CLI script that uses this function: CLI Convert image tool</p> PARAMETER DESCRIPTION <code>args</code> <p>List of command line arguments. If None, uses sys.argv.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the written ND2 file.</p>"},{"location":"experiment/","title":"Experiment module","text":"<p>This module stores classes and functions for handling experiment data in <code>.nd2</code> file.</p> <p>Experiments in .nd2 files define how image sequences are organized and looped. The most common types of loops include:</p> <ul> <li>Time Loop (timeloop): A sequence of images captured over time.</li> <li>Z-Stack (zstack): Frames stacked along the z-axis, representing different focal planes.</li> <li>Multi-Point (multipoint): Images captured at multiple specified locations (points) with known coordinates.</li> </ul> <p>An image can have no experiment, a single experiment, or a combination of multiple experiments.</p> <p>This experiment data is stored in the <code>ExperimentLevel</code> class, you can get instance of this class by getting <code>experiment</code> peoperty of <code>Nd2Reader</code> object.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLoopType","title":"ExperimentLoopType","text":"<p>Enum specifiying which experiment type was used in <code>ExperimentLevel</code></p> ATTRIBUTE DESCRIPTION <code>eEtTimeLoop</code> <p>Timeloop experiment (see <code>ExperimentTimeLoop</code>)</p> <p> TYPE: <code>int</code> </p> <code>eEtNETimeLoop</code> <p>Nonequidistant timeloop experiment (see <code>ExperimentNETimeLoop</code>)</p> <p> TYPE: <code>int</code> </p> <code>eEtXYPosLoop</code> <p>Multipoint experiment (see <code>ExperimentXYPosLoop</code>)</p> <p> TYPE: <code>int</code> </p> <code>eEtZStackLoop</code> <p>Z-stack experiment (see <code>ExperimentZStackLoop</code>)</p> <p> TYPE: <code>int</code> </p> <code>eEtSpectLoop</code> <p>Spectral experiment (see <code>ExperimentSpectralLoop</code>)</p> <p> TYPE: <code>int</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentLoopType.toLongName","title":"toLongName  <code>staticmethod</code>","text":"<pre><code>toLongName(eType: ExperimentLoopType | int)\n</code></pre> <p>Returns long name for experiment type.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLoopType.toShortName","title":"toShortName  <code>staticmethod</code>","text":"<pre><code>toShortName(eType: ExperimentLoopType | int)\n</code></pre> <p>Returns short name for experiment type.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel","title":"ExperimentLevel  <code>dataclass</code>","text":"<pre><code>ExperimentLevel()\n</code></pre> <p>This class stores information about experiments used in an image, this class stores information about one experiment level directly and it may contain nested experiments (similar to linked list data structure).</p> <p>This nesting of experimtents is used to define the order of experiments in the image.</p> <p>To iterate over all experiments in the image, iterate over this class instance in for loop like this:</p> <pre><code>for exp in experiment:\n    print(exp.name)\n    print(exp.count)\n    # another experiment specific instructions\n</code></pre> <p>Each experiment level has a type, which is defined by <code>ExperimentLoopType</code> enum stored in <code>eType</code> attribute, this type defines which experiment parameters are used in given level, those parameters are stored in <code>uLoopPars</code> attribute.</p> <p>In order to get experiment of specific type, use <code>findLevel</code> method with an instance of <code>ExperimentLoopType</code> enum as argument.</p> <p>This will allow you to get attributes for specific experiment type, for example, to get z-stack loop experiment attributes, use this code:</p> <pre><code>zstack = experiment.findLevel(limnd2.ExperimentLoopType.eEtZStackLoop)\n</code></pre> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>eType</code> <p>Experiment type used in the image, also defines which parameters are used in this level.</p> <p> TYPE: <code>ExperimentLoopType</code> </p> <code>uLoopPars</code> <p>Parameters of the current level loop, the structure depends on the content of <code>eType</code> member variable.</p> <p> TYPE: <code>ExperimentLoop</code> </p> <code>ppNextLevelEx</code> <p>List of nested ExperimentLevel instances.</p> <p> TYPE: <code>list[ExperimentLevel]</code> </p> <code>uiNextLevelCount</code> <p>Number of nested experiments.</p> <p> TYPE: <code>int</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>Returns number of frames in the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: dict[str, int]\n</code></pre> <p>Returns a dictionary mapping each experiment to number of frames in that experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.isLambda","title":"isLambda  <code>property</code>","text":"<pre><code>isLambda: bool\n</code></pre> <p>Checks if experiment is spectral loop experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Returns name of the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.shortName","title":"shortName  <code>property</code>","text":"<pre><code>shortName: str\n</code></pre> <p>Returns short name of the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.typeName","title":"typeName  <code>property</code>","text":"<pre><code>typeName: str\n</code></pre> <p>Returns type name of the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.valid","title":"valid  <code>property</code>","text":"<pre><code>valid: bool\n</code></pre> <p>Checks if experiment and all subexperiments are valid.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.dimnames","title":"dimnames","text":"<pre><code>dimnames(*, skipSpectralLoop: bool = True) -&gt; tuple[str]\n</code></pre> <p>Returns names of nested dimensions.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.findLevel","title":"findLevel","text":"<pre><code>findLevel(loopType: ExperimentLoopType) -&gt; ExperimentLevel | None\n</code></pre> <p>Find and returns experiment of specified type or None.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.generateLoopIndexes","title":"generateLoopIndexes","text":"<pre><code>generateLoopIndexes(*, named: bool = False) -&gt; list[tuple]\n</code></pre> <p>Generate list of indexes for all experiments in the image.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.indexOfLoop","title":"indexOfLoop","text":"<pre><code>indexOfLoop(loopType: ExperimentLoopType, *, skipSpectralLoop: bool = True) -&gt; int | None\n</code></pre> <p>Returns index of specified loop type or None.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.loopTypes","title":"loopTypes","text":"<pre><code>loopTypes(*, skipSpectralLoop: bool = True) -&gt; tuple[ExperimentLoopType]\n</code></pre> <p>Returns tuple with <code>ExperimentLoopType</code> instances of all experiments in the image.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.ndim","title":"ndim","text":"<pre><code>ndim(skipSpectralLoop: bool = True) -&gt; int\n</code></pre> <p>Returns number of experiments in the experiment level.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel.shape","title":"shape","text":"<pre><code>shape(*, skipSpectralLoop: bool = True) -&gt; tuple[int]\n</code></pre> <p>Returns shape of the experiment. (number of frames in each experiment)</p>"},{"location":"experiment/#limnd2.experiment.ExperimentTimeLoop","title":"ExperimentTimeLoop  <code>dataclass</code>","text":"<pre><code>ExperimentTimeLoop(*, dStart: float = LV_field(0, DOUBLE), dPeriod: float = LV_field(0, DOUBLE), dDuration: float = LV_field(0, DOUBLE), dMinPeriodDiff: float = LV_field(0, DOUBLE), dMaxPeriodDiff: float = LV_field(0, DOUBLE), dAvgPeriodDiff: float = LV_field(0, DOUBLE), wsPhaseName: str = LV_field('', STRING), sAutoFocusBeforePeriod: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), sAutoFocusBeforeCapture: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), uiLoopType: ExperimentType = LV_field(eEtDefault, UINT32), uiGroup: int = LV_field(0, UINT32), uiStimulationCount: int = LV_field(0, UINT32), bDurationPref: bool = LV_field(None, BOOL), pIncubationData: bytes = LV_field(b'', UNKNOWN), uiIncubationDataSize: int = LV_field(0, UNKNOWN), wsInterfaceName: str = LV_field('', STRING), uiTreatment: int = LV_field(0, UINT32), dIncubationDuration: float = LV_field(-1.0, DOUBLE))\n</code></pre> <p>Dataclass storing parameters about timeloop experiment in the image.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>uiCount</code> <p>Number of frames in the experiment</p> <p> TYPE: <code>int</code> </p> <code>dStart</code> <p>Start time of the experiment</p> <p> TYPE: <code>float</code> </p> <code>dPeriod</code> <p>Time interval between frames in miliseconds.</p> <p> TYPE: <code>float</code> </p> <code>dDuration</code> <p>Duration of the experiment in miliseconds. If value is non-zero, dPeriod must be zero and the experiment is captured as fast as possible for dDuration ms.</p> <p> TYPE: <code>float</code> </p> <code>dMinPeriodDiff</code> <p>Minimum difference between periods.</p> <p> TYPE: <code>float</code> </p> <code>dMaxPeriodDiff</code> <p>Maximum difference between periods.</p> <p> TYPE: <code>float</code> </p> <code>dAvgPeriodDiff</code> <p>Average difference between periods.</p> <p> TYPE: <code>float</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentTimeLoop.formattedDuration","title":"formattedDuration  <code>property</code>","text":"<pre><code>formattedDuration: str\n</code></pre> <p>Returns formatted duration of the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentTimeLoop.formattedInterval","title":"formattedInterval  <code>property</code>","text":"<pre><code>formattedInterval: str\n</code></pre> <p>Returns formatted time interval between frames.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentTimeLoop.info","title":"info  <code>property</code>","text":"<pre><code>info: list[dict[str, any]]\n</code></pre> <p>Returns information about timeloop experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentNETimeLoop","title":"ExperimentNETimeLoop  <code>dataclass</code>","text":"<pre><code>ExperimentNETimeLoop(*, uiPeriodCount: int = LV_field(0, UINT32), pPeriod: list[ExperimentTimeLoop] = LV_field(list, LEVEL), pSubLoops: dict | None = LV_field(None, ENCODING_NOT_IMPLEMENTED), sAutoFocusBeforePeriod: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), sAutoFocusBeforeCapture: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), wsCommandBeforePeriod: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), wsCommandAfterPeriod: dict = LV_field(dict, ENCODING_NOT_IMPLEMENTED), pPeriodValid: bytes = LV_field(bytes, BYTEARRAY))\n</code></pre> <p>Dataclass for storing parameters about nonequidistant time loop experiment. This is done by storing a list of <code>ExperimentTimeLoop</code> instances (each one is called a period).</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>uiCount</code> <p>Number of frames in the experiment (total from frames in all periods)</p> <p> TYPE: <code>int</code> </p> <code>uiPeriodCount</code> <p>Number of periods in the experiment</p> <p> TYPE: <code>int</code> </p> <code>pPeriod</code> <p>List of periods in the nonequidistant time loop experiment</p> <p> TYPE: <code>list[ExperimentTimeLoop]</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentNETimeLoop.info","title":"info  <code>property</code>","text":"<pre><code>info: list[dict[str, any]]\n</code></pre> <p>Returns information about nonequidistant time loop experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentXYPosLoopPoint","title":"ExperimentXYPosLoopPoint  <code>dataclass</code>","text":"<pre><code>ExperimentXYPosLoopPoint(*, dPosX: float = LV_field(0.0, DOUBLE), dPosY: float = LV_field(0.0, DOUBLE), dPosZ: float = LV_field(0.0, DOUBLE), dPFSOffset: float = LV_field(0.0, DOUBLE), dPosName: str = LV_field('', STRING))\n</code></pre> <p>Dataclass for storing infomartion about a single point in multipoint experiment.</p> ATTRIBUTE DESCRIPTION <code>dPosX</code> <p>The X-coordinate of the position.</p> <p> TYPE: <code>float</code> </p> <code>dPosY</code> <p>The Y-coordinate of the position.</p> <p> TYPE: <code>float</code> </p> <code>dPosZ</code> <p>The Z-coordinate of the position.</p> <p> TYPE: <code>float</code> </p> <code>dPFSOffset</code> <p>The offset applied for Perfect Focus System (PFS).</p> <p> TYPE: <code>float</code> </p> <code>dPosName</code> <p>A descriptive name for the position.</p> <p> TYPE: <code>str</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentXYPosLoop","title":"ExperimentXYPosLoop  <code>dataclass</code>","text":"<pre><code>ExperimentXYPosLoop()\n</code></pre> <p>Dataclass for storing parameters about multipoint experiment in the image.</p> ATTRIBUTE DESCRIPTION <code>bUseZ</code> <p>Whether Z-axis positions are used in the experiment.</p> <p> TYPE: <code>bool</code> </p> <code>bRelativeXY</code> <p>Whether XY coordinates are defined relative to a reference point.</p> <p> TYPE: <code>bool</code> </p> <code>dReferenceX</code> <p>The X-coordinate of the reference point.</p> <p> TYPE: <code>float</code> </p> <code>dReferenceY</code> <p>The Y-coordinate of the reference point.</p> <p> TYPE: <code>float</code> </p> <code>bRedefineAfterPFS</code> <p>Whether to redefine points after using the Perfect Focus System (PFS).</p> <p> TYPE: <code>bool</code> </p> <code>bRedefineAfterAutoFocus</code> <p>Whether to redefine points after performing autofocus.</p> <p> TYPE: <code>bool</code> </p> <code>bKeepPFSOn</code> <p>Whether to keep the Perfect Focus System (PFS) active during the experiment.</p> <p> TYPE: <code>bool</code> </p> <code>bSplitMultipoints</code> <p>Whether to split multipoints into separate groups or sequences.</p> <p> TYPE: <code>bool</code> </p> <code>bUseAFPlane</code> <p>Whether to use the autofocus plane for determining Z positions.</p> <p> TYPE: <code>bool</code> </p> <code>bZEnabled</code> <p>Whether the Z-axis is enabled in the experiment.</p> <p> TYPE: <code>bool</code> </p> <code>sZDevice</code> <p>The name of the Z-axis device used in the experiment.</p> <p> TYPE: <code>str</code> </p> <code>sAFBefore</code> <p>Settings for autofocus performed before the experiment.</p> <p> TYPE: <code>dict</code> </p> <code>Points</code> <p>A list of points defining the XY positions for the experiment.</p> <p> TYPE: <code>list of ExperimentXYPosLoopPoint</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentXYPosLoop.info","title":"info  <code>property</code>","text":"<pre><code>info: list[dict[str, any]]\n</code></pre> <p>Returns information about multipoint experiment.</p>"},{"location":"experiment/#limnd2.experiment.ZStackType","title":"ZStackType","text":"<p>Enumeration of Z stack movement types.</p> ATTRIBUTE DESCRIPTION <code>zstBottomToTopFixedTop</code> <p>Bottom -&gt; Top stack with a fixed Top position.</p> <p> TYPE: <code>int</code> </p> <code>zstBottomToTopFixedBottom</code> <p>Bottom -&gt; Top stack with a fixed Bottom position.</p> <p> TYPE: <code>int</code> </p> <code>zstSymmetricRangeFixedHomeBottomToTop</code> <p>Symmetric range around a fixed Home position (Bottom -&gt; Top).</p> <p> TYPE: <code>int</code> </p> <code>zstAsymmetricRangeFixedHomeBottomToTop</code> <p>Asymmetric range around a fixed Home position (Bottom -&gt; Top).</p> <p> TYPE: <code>int</code> </p> <code>zstTopToBottomFixedTop</code> <p>Top -&gt; Bottom stack with a fixed Top position.</p> <p> TYPE: <code>int</code> </p> <code>zstTopToBottomFixedBottom</code> <p>Top -&gt; Bottom stack with a fixed Bottom position.</p> <p> TYPE: <code>int</code> </p> <code>zstSymmetricRangeFixedHomeTopToBottom</code> <p>Symmetric range around a fixed Home position (Top -&gt; Bottom).</p> <p> TYPE: <code>int</code> </p> <code>zstAsymmetricRangeFixedHomeTopToBottom</code> <p>Asymmetric range around a fixed Home position (Top -&gt; Bottom).</p> <p> TYPE: <code>int</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop","title":"ExperimentZStackLoop  <code>dataclass</code>","text":"<pre><code>ExperimentZStackLoop()\n</code></pre> <p>Dataclass for storing parameters about Z-stack experiment in the image.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>uiCount</code> <p>Number of frames in the experiment (total from frames in all periods)</p> <p> TYPE: <code>int</code> </p> <code>dZLow</code> <p>The lowest Z position in the experiment.</p> <p> TYPE: <code>float</code> </p> <code>dZLowPFSOffset</code> <p>Offset applied to the lowest Z position for Perfect Focus System (PFS).</p> <p> TYPE: <code>float</code> </p> <code>dZHigh</code> <p>The highest Z position in the experiment.</p> <p> TYPE: <code>float</code> </p> <code>dZHighPFSOffset</code> <p>Offset applied to the highest Z position for Perfect Focus System (PFS).</p> <p> TYPE: <code>float</code> </p> <code>dZHome</code> <p>The home (central) Z position in the experiment.</p> <p> TYPE: <code>float</code> </p> <code>dZStep</code> <p>Step size between Z positions in the experiment.</p> <p> TYPE: <code>float</code> </p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop.bottom","title":"bottom  <code>property</code>","text":"<pre><code>bottom\n</code></pre> <p>Returns the lowest Z position in the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop.homeIndex","title":"homeIndex  <code>property</code>","text":"<pre><code>homeIndex\n</code></pre> <p>Returns index of the frame with home position.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop.info","title":"info  <code>property</code>","text":"<pre><code>info: list[dict[str, any]]\n</code></pre> <p>Returns information about zstack experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop.step","title":"step  <code>property</code>","text":"<pre><code>step\n</code></pre> <p>Returns step size between Z positions in the experiment in micrometers.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentZStackLoop.top","title":"top  <code>property</code>","text":"<pre><code>top\n</code></pre> <p>Returns the highest Z position in the experiment.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentSpectralLoop","title":"ExperimentSpectralLoop  <code>dataclass</code>","text":"<pre><code>ExperimentSpectralLoop()\n</code></pre> <p>Dataclass for storing parameters about spectral loop experiment in the image.</p>"},{"location":"experiment/#limnd2.experiment.ExperimentSpectralLoop.info","title":"info  <code>property</code>","text":"<pre><code>info: list[dict[str, any]]\n</code></pre> <p>Returns information about spectral loop experiment.</p>"},{"location":"experiment_factory/","title":"Experiment factory module","text":"<p>This module contains helper classes and functions for creating <code>ExperimentLevel</code> instances using simplified parameters for each experiment type. Those instances should be used with <code>Nd2Writer</code> instance for altering / creating <code>.nd2</code> files.</p> <p>Info</p> <p>Since this module is used to creating experiment data structures, you should not use any part of this module if you only read an <code>.nd2</code> file.</p> <p>For creating experiments, you should use <code>ExperimentFactory</code> class.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory","title":"ExperimentFactory","text":"<pre><code>ExperimentFactory(*, t: int | dict[str, Any] | None = None, m: int | dict[str, Any] | None = None, z: int | dict[str, Any] | None = None)\n</code></pre> <p>Helper class for creating experiments, see examples below on how to create timeloop, multipoint and z-stack experiments either directly on factory constructor or by modifying values later.</p> <p>To actually create experiment instance, make sure to call either <code>.createExperiment()</code> method or use call operator.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory--sample-usage","title":"Sample usage","text":"<pre><code>from limnd2.experiment_factory import ExperimentFactory\n\n# only frame counts\nprint(ExperimentFactory(t=10, m=5).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(10 frames, interval: No Delay, duration: Continuous), Multipoint experiment(5 frames, point coordinates: [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0])</code></p> <pre><code># values from dict\nprint(ExperimentFactory(t={\"count\" : 3, \"step\": 350}, z={\"count\" : 5, \"step\": 150}).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: 0:00:00.350, duration: Continuous), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code># combination\nprint(ExperimentFactory(t=3, z={\"count\" : 5, \"step\": 150}).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: No Delay, duration: Continuous), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code># create factory and modify it\nfac = ExperimentFactory()\nfac.z.count = 10\nfac.z.step = 100\nprint(fac())            # createExperiment is called implicitly\n</code></pre> See example output <p><code>Z-Stack experiment(10 frames, step: 100.0)</code></p> <pre><code>fac = ExperimentFactory()\nfac.m.addPoint(10, 50)\nfac.m.addPoint(20, 70)\nprint(fac())\n</code></pre> See example output <p><code>Multipoint experiment(2 frames, point coordinates: [10.0, 50.0], [20.0, 70.0])</code></p> <pre><code># inlined multipoint\nprint(ExperimentFactory(t=3, z={\"count\" : 5, \"step\": 150}, m={\"count\" : 3, \"xcoords\" : [10,20,30], \"ycoords\" : [40,50,60]})())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: No Delay, duration: Continuous), Multipoint experiment(3 frames, point coordinates: [10.0, 40.0], [20.0, 50.0], [30.0, 60.0]), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code>fac = ExperimentFactory()\nfac.t.count = 10\nfac.z.step = 100\nprint(fac())\n</code></pre> <p>Warning</p> <p>In this example Z-Stack experiment will be omitted from output since Z-stack frame count is not set, even though Z-stack step property was defined.</p> See example output <p><code>Timeloop experiment(10 frames, interval: No Delay, duration: Continuous)</code></p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; ExperimentLevel\n</code></pre> <p>Create <code>ExperimentLevel</code> instance using specified settings.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory.createExperiment","title":"createExperiment","text":"<pre><code>createExperiment() -&gt; ExperimentLevel\n</code></pre> <p>Create <code>ExperimentLevel</code> instance using specified settings.</p>"},{"location":"metadata/","title":"Metadata module","text":"<p>This module module stores comprehensive metadata related to microscopy images. Key data includes:</p> <ul> <li> <p>Picture Planes: Descriptions of individual image components or channels, including their modalities and spectral properties.</p> <p>See <code>PicturePlaneDesc</code> class storing information about individual image plane.</p> <p>Or <code>PictureMetadataPicturePlanes</code> class storing information about all image planes.</p> </li> <li> <p>Sample settings: The SampleSettings class stores various settings and configurations related to the sample being imaged.     One sample setting can be used by one or multiple image planes in <code>PictureMetadataPicturePlanes</code>.</p> <p>See <code>SampleSettings</code> dataclass for more information.</p> </li> </ul> <p>All data about planes and their settings are stored in <code>PictureMetadata</code> class.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata","title":"PictureMetadata  <code>dataclass</code>","text":"<pre><code>PictureMetadata()\n</code></pre> <p>Dataclass for storing metadata associated with a captured picture.</p> <p>Stores some attributes valid for whole image, metadata for individual channels can be retrieved using <code>PictureMetadata.channels</code> attribute.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>dTimeAbsolute</code> <p>The absolute time the picture was captured, specified as a Julian Day Number.</p> <p> TYPE: <code>float</code> </p> <code>sPicturePlanes</code> <p>Information about the picture's planes and their settings.</p> <p> TYPE: <code>PictureMetadataPicturePlanes</code> </p> <code>dCalibration</code> <p>Calibration factor specifying the conversion from microns to pixels.</p> <p> TYPE: <code>float</code> </p> <code>dCalibPrecision</code> <p>The precision of the calibration in microns.</p> <p> TYPE: <code>float</code> </p> <code>bCalibrated</code> <p>Indicates whether the calibration is valid.</p> <p> TYPE: <code>bool</code> </p> <code>dAspect</code> <p>The pixel aspect ratio.</p> <p> TYPE: <code>float</code> </p> <code>dObjectiveMag</code> <p>The magnification factor of the objective lens.</p> <p> TYPE: <code>float</code> </p> <code>dObjectiveNA</code> <p>The numerical aperture of the objective lens.</p> <p> TYPE: <code>float</code> </p> <code>dRefractIndex1</code> <p>The refractive index of the medium at the objective side.</p> <p> TYPE: <code>float</code> </p> <code>dZoom</code> <p>The zoom factor used during image capture.</p> <p> TYPE: <code>float</code> </p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.channelNames","title":"channelNames  <code>property</code>","text":"<pre><code>channelNames: list[str]\n</code></pre> <p>Returns names of all channels (planes).</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.channels","title":"channels  <code>property</code>","text":"<pre><code>channels: list[PicturePlaneDesc]\n</code></pre> <p>Returns list of channels (planes) in the image.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.componentColors","title":"componentColors  <code>property</code>","text":"<pre><code>componentColors: list[tuple[float, float, float]]\n</code></pre> <p>Returns colors of each component as normalized tuple in a list.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.componentNames","title":"componentNames  <code>property</code>","text":"<pre><code>componentNames: list[str]\n</code></pre> <p>Returns names of all components.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.isRgb","title":"isRgb  <code>property</code>","text":"<pre><code>isRgb: bool\n</code></pre> <p>Checks if image is an RGB image.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.valid","title":"valid  <code>property</code>","text":"<pre><code>valid: bool\n</code></pre> <p>Checks if metadata have correct number of channels.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.cameraName","title":"cameraName","text":"<pre><code>cameraName(plane: int | PicturePlaneDesc = 0) -&gt; str\n</code></pre> <p>Returns camera name using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.makeValid","title":"makeValid","text":"<pre><code>makeValid(comps: int, **kwargs) -&gt; None\n</code></pre> <p>Attempts to fix info about channels using specified number of channels.</p> <p>This function creates channel info basec on component count like this:</p> <pre><code>comps == 1: function creates one Mono channel\ncomps == 2: function creates channels Channel_1, Channel_2\ncomps == 3: function creates one RGB channel\ncomps &gt;= 4: function creates channels Channel_1, ..., Channel_N\n</code></pre> PARAMETER DESCRIPTION <code>comps</code> <p>The number of components in the image.</p> <p> TYPE: <code>int</code> </p> <code>**kwargs</code> <p>Additional parameters to pass to each plane.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.microscopeName","title":"microscopeName","text":"<pre><code>microscopeName(plane: int | PicturePlaneDesc = 0) -&gt; str\n</code></pre> <p>Returns microscope name using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.objectiveMagnification","title":"objectiveMagnification","text":"<pre><code>objectiveMagnification(plane: int | PicturePlaneDesc = 0) -&gt; float\n</code></pre> <p>Returns objective magnification using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.objectiveName","title":"objectiveName","text":"<pre><code>objectiveName(plane: int | PicturePlaneDesc = 0) -&gt; str\n</code></pre> <p>Returns name of objective using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.objectiveNumericAperture","title":"objectiveNumericAperture","text":"<pre><code>objectiveNumericAperture(plane: int | PicturePlaneDesc = 0) -&gt; float\n</code></pre> <p>Returns objective numeric aperture using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.opticalConfigurations","title":"opticalConfigurations","text":"<pre><code>opticalConfigurations(plane: int | PicturePlaneDesc = 0) -&gt; list[str]\n</code></pre> <p>Returns list of optical configurations.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.refractiveIndex","title":"refractiveIndex","text":"<pre><code>refractiveIndex(plane: int | PicturePlaneDesc = 0) -&gt; float\n</code></pre> <p>Returns refractive index using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadata.sampleSettings","title":"sampleSettings","text":"<pre><code>sampleSettings(plane: int | PicturePlaneDesc = 0) -&gt; SampleSettings | None\n</code></pre> <p>Returns an instance of <code>SampleSettings</code> using either <code>PicturePlaneDesc</code> instance or an index of channel.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes","title":"PictureMetadataPicturePlanes  <code>dataclass</code>","text":"<pre><code>PictureMetadataPicturePlanes()\n</code></pre> <p>Stores metadata for the picture planes and their associated settings in a microscopy imaging experiment.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>uiCount</code> <p>The number of picture planes in <code>sPlaneNew</code>.</p> <p> TYPE: <code>int</code> </p> <code>uiCompCount</code> <p>The total number of components across all picture planes. It is the sum of <code>uiCompCount</code> values from all members of <code>sPlaneNew</code>.</p> <p> TYPE: <code>int</code> </p> <code>sPlaneNew</code> <p>A list of <code>PicturePlaneDesc</code> objects, each representing metadata for a single picture plane.</p> <p> TYPE: <code>list[PicturePlaneDesc]</code> </p> <code>uiSampleCount</code> <p>The number of sample settings in the file.</p> <p> TYPE: <code>int</code> </p> <code>sSampleSetting</code> <p>A list of <code>SampleSettings</code> objects, each containing the detailed configuration for a sample, one sample setting can be used for one or multiple planes.</p> <p> TYPE: <code>list[SampleSettings]</code> </p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.valid","title":"valid  <code>property</code>","text":"<pre><code>valid: bool\n</code></pre> <p>Checks if PictureMetadataPicturePlanes insance has valid number of channels.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if number of channels is valid, False otherwise.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.makeValid","title":"makeValid","text":"<pre><code>makeValid(comps: int, **kwargs) -&gt; None\n</code></pre> <p>Attempts to fix info about channels using specified number of channels.</p> <p>This function creates channel info basec on component count like this:</p> <pre><code>comps == 1: function creates one Mono channel\ncomps == 2: function creates channels Channel_1, Channel_2\ncomps == 3: function creates one RGB channel\ncomps &gt;= 4: function creates channels Channel_1, ..., Channel_N\n</code></pre> PARAMETER DESCRIPTION <code>comps</code> <p>The number of components in the image.</p> <p> TYPE: <code>int</code> </p> <code>**kwargs</code> <p>Additional parameters to pass to each plane.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc","title":"PicturePlaneDesc  <code>dataclass</code>","text":"<pre><code>PicturePlaneDesc()\n</code></pre> <p>Metadata for a single plane in a picture, typically used in microscopy or imaging systems.</p> <p>This class contains information about the image plane's calibration, modality, fluorescent probe, optical filter path, acquisition settings, and other relevant details that define how the image plane was captured and how it should be processed.</p> <p>Some metadata is stored in this class directly, more information is stored in corresponding <code>SampleSettings</code> instance, this <code>SampleSetting</code> instance can be retvieved calling <code>PictureMetadata.sampleSettings</code> function with an instance of this class as a parameter.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>uiCompCount</code> <p>The number of components in the picture plane, usually it is 1, can be 3 for an RGB image.</p> <p> TYPE: <code>int</code> </p> <code>uiSampleIndex</code> <p>Hold index of sample settings used for this picture plane. See <code>PictureMetadataPicturePlanes.sSampleSetting</code> attribute storing sample settings.</p> <p> TYPE: <code>int</code> </p> <code>dObjCalibration1to1</code> <p>Calibration factor for the camera chip used during acquisition.</p> <p> TYPE: <code>float</code> </p> <code>uiModalityMask</code> <p>Bitmask indicating the modality of the picture plane, such as fluorescence.</p> <p> TYPE: <code>PicturePlaneModalityFlags</code> </p> <code>pFluorescentProbe</code> <p>Description of the fluorescent probe used in the picture plane.</p> <p> TYPE: <code>FluorescentProbe</code> </p> <code>pFilterPath</code> <p>Describes the optical filter path used in the picture plane.</p> <p> TYPE: <code>OpticalFilterPath</code> </p> <code>uiColor</code> <p>Color used for representing the picture plane.</p> <p> TYPE: <code>int</code> </p> <code>sDescription</code> <p>Name for the picture plane.</p> <p> TYPE: <code>str</code> </p> <code>dAcqTime</code> <p>Acquisition time for one single image plane. This can vary for different planes in a picture.</p> <p> TYPE: <code>float</code> </p> <code>dPinholeDiameter</code> <p>The diameter of the pinhole used in the optical setup, in micrometers.</p> <p> TYPE: <code>float</code> </p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.colorAsClampedTuple","title":"colorAsClampedTuple  <code>property</code>","text":"<pre><code>colorAsClampedTuple\n</code></pre> <p>Get the color of the picture plane as an RGB tuple normalized to range [0.0, 1.0].</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.colorAsHtmlString","title":"colorAsHtmlString  <code>property</code>","text":"<pre><code>colorAsHtmlString\n</code></pre> <p>Get the color of the picture plane as HTML string.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.colorAsTuple","title":"colorAsTuple  <code>property</code>","text":"<pre><code>colorAsTuple\n</code></pre> <p>Get the color of the picture plane as an RGB tuple.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.emissionWavelengthNm","title":"emissionWavelengthNm  <code>cached</code> <code>property</code>","text":"<pre><code>emissionWavelengthNm: float\n</code></pre> <p>Returns the single emission wavelength for the picture plane, calculated from the fluorescent probe or optical filter path.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.excitationWavelengthNm","title":"excitationWavelengthNm  <code>cached</code> <code>property</code>","text":"<pre><code>excitationWavelengthNm: float\n</code></pre> <p>Returns the single excitation wavelength for the picture plane, calculated from the fluorescent probe or optical filter path.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.isBrightfield","title":"isBrightfield  <code>property</code>","text":"<pre><code>isBrightfield: bool\n</code></pre> <p>Returns whether the picture plane is a brightfield image.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.isContrast","title":"isContrast  <code>property</code>","text":"<pre><code>isContrast: bool\n</code></pre> <p>Returns whether the picture plane is a contrast image.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.isDarkfield","title":"isDarkfield  <code>property</code>","text":"<pre><code>isDarkfield: bool\n</code></pre> <p>Returns whether the picture plane is a darkfield image.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.isFluorescence","title":"isFluorescence  <code>property</code>","text":"<pre><code>isFluorescence: bool\n</code></pre> <p>Returns whether the picture plane is a fluorescence image.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.modalityList","title":"modalityList  <code>property</code>","text":"<pre><code>modalityList: list[str]\n</code></pre> <p>Returns a list of modalities present in the picture plane converted to strings.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings","title":"SampleSettings  <code>dataclass</code>","text":"<pre><code>SampleSettings()\n</code></pre> <p>Stores settings related to the acquisition of an image, including information about the camera, device, objective lens, and optical configurations.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>pCameraSetting</code> <p>The camera settings used during image acquisition, including camera-specific properties such as name, type, and family.</p> <p> TYPE: <code>CameraSetting</code> </p> <code>pDeviceSetting</code> <p>Settings related to the device or microscope used for imaging, including microscope names, size, and usage.</p> <p> TYPE: <code>DeviceSetting</code> </p> <code>pObjectiveSetting</code> <p>Details of the objective lens used during acquisition, such as magnification, numerical aperture, and refractive index.</p> <p> TYPE: <code>ObjectiveSetting</code> </p> <code>sOpticalConfigs</code> <p>A list of optical configurations used during imaging, each represented as a <code>SampleSettingsOC</code> object.</p> <p> TYPE: <code>list[SampleSettingsOC]</code> </p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.cameraName","title":"cameraName  <code>property</code>","text":"<pre><code>cameraName: str\n</code></pre> <p>Return name of the camera used to aquire given sample.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.microscopeName","title":"microscopeName  <code>property</code>","text":"<pre><code>microscopeName: str\n</code></pre> <p>Return name of the microscope used to aquire given sample.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.objectiveCode","title":"objectiveCode  <code>property</code>","text":"<pre><code>objectiveCode: str\n</code></pre> <p>Return name of the camera used to aquire given sample.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.objectiveMagnification","title":"objectiveMagnification  <code>property</code>","text":"<pre><code>objectiveMagnification: float\n</code></pre> <p>Return magification of used objective.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.objectiveName","title":"objectiveName  <code>property</code>","text":"<pre><code>objectiveName: str\n</code></pre> <p>Return name of the objective used to aquire given sample.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.objectiveNumericAperture","title":"objectiveNumericAperture  <code>property</code>","text":"<pre><code>objectiveNumericAperture: float\n</code></pre> <p>Return numerical aperture of used objective lens.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.opticalConfigurations","title":"opticalConfigurations  <code>property</code>","text":"<pre><code>opticalConfigurations: list[str]\n</code></pre> <p>Return list of all optical configurations.</p>"},{"location":"metadata/#limnd2.metadata.SampleSettings.refractiveIndex","title":"refractiveIndex  <code>property</code>","text":"<pre><code>refractiveIndex: float\n</code></pre> <p>Return refractive index of the medium in given sample.</p>"},{"location":"metadata/#limnd2.metadata.CameraSetting","title":"CameraSetting  <code>dataclass</code>","text":"<pre><code>CameraSetting()\n</code></pre> <p>Stores information about the camera used for image acquisition.</p> ATTRIBUTE DESCRIPTION <code>CameraUniqueName</code> <p>A unique name identifier for the camera.</p> <p> TYPE: <code>str</code> </p> <code>CameraUserName</code> <p>The user-assigned name for the camera.</p> <p> TYPE: <code>str</code> </p> <code>CameraFamilyName</code> <p>The name of the camera family or model group.</p> <p> TYPE: <code>str</code> </p>"},{"location":"metadata/#limnd2.metadata.DeviceSetting","title":"DeviceSetting  <code>dataclass</code>","text":"<pre><code>DeviceSetting()\n</code></pre> <p>Stores information about the microscope device settings.Stores information about the microscope device settings.</p> ATTRIBUTE DESCRIPTION <code>m_sMicroscopeFullName</code> <p>The full name of the microscope.</p> <p> TYPE: <code>str</code> </p> <code>m_sMicroscopeShortName</code> <p>A short name for the microscope.</p> <p> TYPE: <code>str</code> </p>"},{"location":"metadata/#limnd2.metadata.FluorescentProbe","title":"FluorescentProbe  <code>dataclass</code>","text":"<pre><code>FluorescentProbe(*, m_sName: str = LV_field('', STRING), m_uiColor: int = LV_field(16777215, UINT32), m_ExcitationSpectrum: OpticalSpectrum = LV_field(OpticalSpectrum, LEVEL), m_EmissionSpectrum: OpticalSpectrum = LV_field(OpticalSpectrum, LEVEL))\n</code></pre> <p>A class representing a fluorescent probe.</p> ATTRIBUTE DESCRIPTION <code>m_sName</code> <p>The name of the fluorescent probe.</p> <p> TYPE: <code>str</code> </p> <code>m_uiColor</code> <p>The color of the probe.</p> <p> TYPE: <code>int</code> </p> <code>m_ExcitationSpectrum</code> <p>An object representing the excitation spectrum of the probe, typically defining the wavelengths at which the probe absorbs light.</p> <p> TYPE: <code>OpticalSpectrum</code> </p> <code>m_EmissionSpectrum</code> <p>An object representing the emission spectrum of the probe, typically defining the wavelengths at which the probe emits light after excitation.</p> <p> TYPE: <code>OpticalSpectrum</code> </p>"},{"location":"metadata/#limnd2.metadata.ObjectiveSetting","title":"ObjectiveSetting  <code>dataclass</code>","text":"<pre><code>ObjectiveSetting(*, wsObjectiveName: str = LV_field('', STRING), wsObjectiveCode: str = LV_field('', STRING), dObjectiveMag: float = LV_field(0.0, DOUBLE), dObjectiveNA: float = LV_field(0.0, DOUBLE), dRefractIndex: float = LV_field(0.0, DOUBLE), bTiltingNosepiece: bool = LV_field(False, BOOL), dHorizontalAngle: float = LV_field(0.0, DOUBLE), dVerticalAngle: float = LV_field(0.0, DOUBLE), dOpticalAxis: float = LV_field(0.0, DOUBLE))\n</code></pre> <p>Stores information about the objective lens used to acquire an image.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>wsObjectiveName</code> <p>The name of the objective lens (e.g., \"40x Objective\" or \"100x Oil Immersion\").</p> <p> TYPE: <code>str</code> </p> <code>dObjectiveMag</code> <p>The magnification power of the objective lens (e.g., 10x, 40x, 100x).</p> <p> TYPE: <code>float</code> </p> <code>dObjectiveNA</code> <p>The numerical aperture (NA) of the objective lens.</p> <p> TYPE: <code>float</code> </p> <code>dRefractIndex</code> <p>The refractive index of the medium between the objective lens and the sample (e.g., air, water, oil).</p> <p> TYPE: <code>float</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalFilter","title":"OpticalFilter  <code>dataclass</code>","text":"<pre><code>OpticalFilter()\n</code></pre> <p>Represents an optical filter in an optical system, typically used in fluorescence microscopy.</p> ATTRIBUTE DESCRIPTION <code>m_sName</code> <p>The name of the optical filter.</p> <p> TYPE: <code>str</code> </p> <code>m_sUserName</code> <p>A user-defined name for the optical filter.</p> <p> TYPE: <code>str</code> </p> <code>m_ePlacement</code> <p>Specifies the position of the filter in the optical path (e.g., excitation, emission, filter turret, etc.).</p> <p> TYPE: <code>OpticalFilterPlacement</code> </p> <code>m_eNature</code> <p>Specifies the nature of the filter (e.g., wide-band, RGB, or specific color filters).</p> <p> TYPE: <code>OpticalFilterNature</code> </p> <code>m_eSpctType</code> <p>Defines the spectrum type of the filter (e.g., bandpass, narrow-bandpass, lowpass, etc.).</p> <p> TYPE: <code>OpticalFilterSpectType</code> </p> <code>m_uiColor</code> <p>The color of the filter.</p> <p> TYPE: <code>int</code> </p> <code>m_ExcitationSpectrum</code> <p>The spectrum of the filter that allows specific excitation wavelengths to pass through.</p> <p> TYPE: <code>OpticalSpectrum</code> </p> <code>m_EmissionSpectrum</code> <p>The spectrum of the filter that allows specific emitted wavelengths to pass through.</p> <p> TYPE: <code>OpticalSpectrum</code> </p> <code>m_MirrorSpectrum</code> <p>The spectrum related to the mirror spectrum.</p> <p> TYPE: <code>OpticalSpectrum</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterNature","title":"OpticalFilterNature","text":"<p>Enumeration that defines the nature of an optical filter, indicating the type of spectra it handles.</p> ATTRIBUTE DESCRIPTION <code>eOfnGeneric</code> <p>A wide-band or unspecified spectrum filter, often used for general applications.</p> <p> TYPE: <code>int</code> </p> <code>eOfnRGB</code> <p>A triple-band filter suitable for use with RGB cameras or for human visual perception.</p> <p> TYPE: <code>int</code> </p> <code>eOfnRed</code> <p>A filter that passes the red part of the spectrum.</p> <p> TYPE: <code>int</code> </p> <code>eOfnGreen</code> <p>A filter that passes the green part of the spectrum.</p> <p> TYPE: <code>int</code> </p> <code>eOfnBlue</code> <p>A filter that passes the blue part of the spectrum.</p> <p> TYPE: <code>int</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterPath","title":"OpticalFilterPath  <code>dataclass</code>","text":"<pre><code>OpticalFilterPath(*, m_sDescr: str = LV_field('', STRING), m_uiCount: int = LV_field(0, UINT32), m_pFilter: list[OpticalFilter] = LV_field(list, LEVEL))\n</code></pre> <p>Represents a path of optical filters within an optical system, typically in fluorescence microscopy setups.</p> ATTRIBUTE DESCRIPTION <code>m_sDescr</code> <p>A description of the optical filter path, typically used for identification or documentation.</p> <p> TYPE: <code>str</code> </p> <code>m_uiCount</code> <p>The number of filters in the optical filter path.</p> <p> TYPE: <code>int</code> </p> <code>m_pFilter</code> <p>A list of <code>OpticalFilter</code> objects, each representing an optical filter in the path.</p> <p> TYPE: <code>list[OpticalFilter]</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterPath.isValid","title":"isValid  <code>property</code>","text":"<pre><code>isValid: bool\n</code></pre> <p>Returns whether the filter path is valid (has at least one filter).</p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterPath.closestExcitationWavelength","title":"closestExcitationWavelength","text":"<pre><code>closestExcitationWavelength(emission: float) -&gt; float\n</code></pre> <p>Finds the excitation wavelength that is closest to a given emission wavelength from the filters in the path.</p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterPath.meanEmissionWavelength","title":"meanEmissionWavelength","text":"<pre><code>meanEmissionWavelength() -&gt; float\n</code></pre> <p>Calculates the mean emission wavelength based on the emission spectra of the filters in the path.</p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterPlacement","title":"OpticalFilterPlacement","text":"<p>Enumeration that defines the placement of an optical filter in an optical system.</p> ATTRIBUTE DESCRIPTION <code>eOfpNoFilter</code> <p>No filter applied.</p> <p> TYPE: <code>int</code> </p> <code>eOfpExcitation</code> <p>Position for the excitation filter, typically located near the light source (lamp).</p> <p> TYPE: <code>int</code> </p> <code>eOfpEmission</code> <p>Position for the emission filter, usually located near the camera.</p> <p> TYPE: <code>int</code> </p> <code>eOfpFilterTurret</code> <p>Position for the filter block, commonly used in fluorescence microscopy systems.</p> <p> TYPE: <code>int</code> </p> <code>eOfpLamp</code> <p>Position related to the lamp's spectrum.</p> <p> TYPE: <code>int</code> </p> <code>eOfnCameraChip</code> <p>Position related to the sensitivity of the camera chip.</p> <p> TYPE: <code>int</code> </p> <code>eOfpUserOverride</code> <p>User-defined emission wavelength position, allowing customization of the filter setup.</p> <p> TYPE: <code>int</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalFilterSpectType","title":"OpticalFilterSpectType","text":"<p>Enumeration that defines the types of optical spectra that an optical filter can handle.</p> ATTRIBUTE DESCRIPTION <code>eOftBandpass</code> <p>A bandpass filter defined by a lower (raising edge) and higher (falling edge) wavelength.</p> <p> TYPE: <code>int</code> </p> <code>eOftNarrowBandpass</code> <p>A narrow bandpass filter specified by a single wavelength (peak).</p> <p> TYPE: <code>int</code> </p> <code>eOftLowpass</code> <p>A lowpass filter specified by one wavelength (falling edge).</p> <p> TYPE: <code>int</code> </p> <code>eOftHighpass</code> <p>A highpass filter specified by one wavelength (raising edge).</p> <p> TYPE: <code>int</code> </p> <code>eOftBarrier</code> <p>A barrier filter defined by a lower (falling edge) and higher (raising edge) wavelength.</p> <p> TYPE: <code>int</code> </p> <code>eOftMultiplepass</code> <p>A filter allowing multiple passes, specified by a few edges.</p> <p> TYPE: <code>int</code> </p> <code>eOftFull</code> <p>The full position in a filterwheel, indicating that the filter allows all wavelengths to pass.</p> <p> TYPE: <code>int</code> </p> <code>eOftEmpty</code> <p>The empty position in a filterwheel, where no filter is present.</p> <p> TYPE: <code>int</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum","title":"OpticalSpectrum  <code>dataclass</code>","text":"<pre><code>OpticalSpectrum(*, uiCount: int = LV_field(0, UINT32), bPoints: bool = LV_field(False, BOOL), pPoint: list[OpticalSpectrumPoint] = LV_field(list, LEVEL))\n</code></pre> <p>Class representing an optical spectrum, consisting of a series of spectrum points.</p> ATTRIBUTE DESCRIPTION <code>uiCount</code> <p>The number of points in the optical spectrum.</p> <p> TYPE: <code>int</code> </p> <code>bPoints</code> <p>A flag indicating whether the spectrum contains only points. (<code>OpticalSpectrumPointType.eSptPoint</code>)</p> <p> TYPE: <code>bool</code> </p> <code>pPoint</code> <p>A list of <code>OpticalSpectrumPoint</code> instances representing the spectrum.</p> <p> TYPE: <code>list[OpticalSpectrumPoint]</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>Returns number of points in the optical spectrum.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.isValid","title":"isValid  <code>property</code>","text":"<pre><code>isValid: bool\n</code></pre> <p>Check whether the optical spectrum is valid (has at least one point).</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.combine","title":"combine  <code>staticmethod</code>","text":"<pre><code>combine(a: OpticalSpectrum, b: OpticalSpectrum) -&gt; OpticalSpectrum\n</code></pre> <p>Combines two optical spectra into a single spectrum.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.findmaxtvalue","title":"findmaxtvalue","text":"<pre><code>findmaxtvalue() -&gt; tuple[int, float]\n</code></pre> <p>Finds the index and value of the maximum dTValue in the spectrum.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.peakAndFWHM","title":"peakAndFWHM","text":"<pre><code>peakAndFWHM() -&gt; tuple[float, float, float]\n</code></pre> <p>Calculates the peak wavelength and Full Width at Half Maximum (FWHM) for the spectrum.</p> RETURNS DESCRIPTION <code>tuple[float, float, float]</code> <p>Wavelegth of lower edge of the FWHM, peak wavelegth and upper edge of the FWHM.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.singleWavelength","title":"singleWavelength","text":"<pre><code>singleWavelength() -&gt; float\n</code></pre> <p>Returns the single representative wavelength for the spectrum, calculated as the peak wavelength or weighted average of wavelengths.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrum.wavelengthRange","title":"wavelengthRange","text":"<pre><code>wavelengthRange() -&gt; tuple[float, float]\n</code></pre> <p>Returns the minimum and maximum wavelengths of the spectrum.</p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrumPoint","title":"OpticalSpectrumPoint  <code>dataclass</code>","text":"<pre><code>OpticalSpectrumPoint()\n</code></pre> <p>Class representing a single point in an optical spectrum.</p> <p>Attributes:</p> <p>Note</p> <p>Only selected attributes are listed, for full list of attributes see class definition.</p> ATTRIBUTE DESCRIPTION <code>eType</code> <p>Type of the point (most commonly <code>OpticalSpectrumPointType.eSptPeak</code> storing peak value).</p> <p> TYPE: <code>OpticalSpectrumPointType</code> </p> <code>dWavelength</code> <p>Wavelength of the point.</p> <p> TYPE: <code>float</code> </p> <code>dTValue</code> <p>Intensity value of the point.</p> <p> TYPE: <code>float</code> </p>"},{"location":"metadata/#limnd2.metadata.OpticalSpectrumPointType","title":"OpticalSpectrumPointType","text":"<p>Enum class representing different types of optical spectrum points.</p> ATTRIBUTE DESCRIPTION <code>eSptInvalid</code> <p>Represents an invalid spectrum point.</p> <p> TYPE: <code>Final</code> </p> <code>eSptPoint</code> <p>Represents a standard spectrum point.</p> <p> TYPE: <code>Final</code> </p> <code>eSptRaisingEdge</code> <p>Represents a raising edge in the spectrum.</p> <p> TYPE: <code>Final</code> </p> <code>eSptFallingEdge</code> <p>Represents a falling edge in the spectrum.</p> <p> TYPE: <code>Final</code> </p> <code>eSptPeak</code> <p>Represents a peak point in the spectrum.</p> <p> TYPE: <code>Final</code> </p> <code>eSptRange</code> <p>Represents a range or span of spectrum points.</p> <p> TYPE: <code>Final</code> </p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModality","title":"PicturePlaneModality","text":"<p>Enum for modality of given plane.</p> <p>Warning</p> <p>In modern .nd2 files this modality enum should be converted to PicturePlaneModalityFlags instance using from_modality() function.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags","title":"PicturePlaneModalityFlags","text":"<p>Enum for modality flags of given plane.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.from_modality","title":"from_modality  <code>staticmethod</code>","text":"<pre><code>from_modality(mod: PicturePlaneModality) -&gt; PicturePlaneModalityFlags\n</code></pre> <p>Converts modality enum to PicturePlaneModalityFlags.</p> PARAMETER DESCRIPTION <code>mod</code> <p>modality enum instance</p> <p> TYPE: <code>PicturePlaneModality</code> </p> RETURNS DESCRIPTION <code>PicturePlaneModalityFlags</code> <p>Modalify flag for given modality</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.from_modality_string","title":"from_modality_string  <code>staticmethod</code>","text":"<pre><code>from_modality_string(modality: str) -&gt; PicturePlaneModalityFlags\n</code></pre> <p>Converts modality string to PicturePlaneModalityFlags.</p> PARAMETER DESCRIPTION <code>modality</code> <p>modality string (for example \"Wide-field\", \"Brightfield\", \"Phase\", ...)</p> <p> TYPE: <code>string</code> </p> RETURNS DESCRIPTION <code>PicturePlaneModalityFlags</code> <p>Modalify flag for given modality, 0 for \"undefined\"</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.modality_OME_map","title":"modality_OME_map  <code>staticmethod</code>","text":"<pre><code>modality_OME_map() -&gt; dict[str, PicturePlaneModalityFlags]\n</code></pre> <p>Returns mapping of modality strings of OME-XML <code>AcquisitionMode</code> and <code>ContrastMethod</code> attributes to <code>PicturePlaneModalityFlags</code>.</p> <p>Note</p> <p>When parsing OME-XML, you must convert <code>AcquisitionMode</code> and <code>ContrastMethod</code> attributes separately and use binary or with the flags.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.modality_list","title":"modality_list  <code>staticmethod</code>","text":"<pre><code>modality_list() -&gt; list[str]\n</code></pre> <p>Returns list of known modality strings (\"Wide-field\", \"Brightfield\", ...).</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.modality_string_map","title":"modality_string_map  <code>staticmethod</code>","text":"<pre><code>modality_string_map() -&gt; dict[str, PicturePlaneModalityFlags]\n</code></pre> <p>Returns mapping of known modality strings (\"Wide-field\", \"Brightfield\", ...) to <code>PicturePlaneModalityFlags</code>.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.to_str_list","title":"to_str_list  <code>staticmethod</code>","text":"<pre><code>to_str_list(flags: PicturePlaneModalityFlags) -&gt; list[str]\n</code></pre> <p>Converts modality flags to list of human readable strings.</p> PARAMETER DESCRIPTION <code>flags</code> <p>odality flags</p> <p> TYPE: <code>PicturePlaneModalityFlags</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>human readable string list, for example [\"Brightfield\", \"Phase\"]</p>"},{"location":"metadata/#limnd2.metadata.SampleSettingsOC","title":"SampleSettingsOC  <code>dataclass</code>","text":"<pre><code>SampleSettingsOC(*, uiOCTypeKey: int = LV_field(0, UINT32), sOpticalConfigName: str = LV_field('', STRING))\n</code></pre> <p>Stores optical configuration settings for a sample.</p> ATTRIBUTE DESCRIPTION <code>sOpticalConfigName</code> <p>The name of the optical configuration being used for the sample.</p> <p> TYPE: <code>str</code> </p>"},{"location":"metadata_factory/","title":"Metadata factory module","text":"<p>This module contains helper classes and functions for creating <code>PictureMetadata</code> instances using simplified parameters for channels and microscope settings. Those instances should be used with <code>Nd2Writer</code> instance for altering / creating <code>.nd2</code> files.</p> <p>Info</p> <p>Since this module is used to creating metadata data structures, you should not use any part of this module if you only read an .nd2 file.</p> <p>For creating metadata, you should use <code>MetadataFactory</code> class.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory","title":"MetadataFactory","text":"<pre><code>MetadataFactory(planes: list[dict[str, Any] | Plane] | None = None, *, pixel_calibration: float = -1.0, **kwargs: Any)\n</code></pre>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.pixel_calibration","title":"pixel_calibration  <code>instance-attribute</code>","text":"<pre><code>pixel_calibration: float = pixel_calibration\n</code></pre> <p>Helper class for creating metadata, see examples below on how to create metadata witch channels and microscope settings.</p> <p>To actually create metadata instance, make sure to call either <code>.createMetadata()</code> method or use call operator.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.pixel_calibration--sample-usage","title":"Sample usage","text":"<p>Make sure to import MetadataFactory class before using it, optionally you can use Plane dataclass if you wish to use it.</p> <pre><code>from limnd2.metadata_factory import MetadataFactory, Plane\n</code></pre> <p>You can create channels and microscope settings on <code>MetadataFactory</code> constructor, or add them later using <code>.addPlane()</code> method.</p> <p>When you add microscope settings to <code>MetadataFactory</code> constructor, those settings will be used for all channels, unless you overwrite them by providing replacement values when creating individual channel.</p> <p>In following example <code>objective_magnification</code> is applied to all channels, <code>immersion_refractive_index</code> however is only applied to <code>Channel2</code>.</p> <p>To see whole list of microscope settings that can be applied per channel or per whole factory, see <code>Plane</code> dataclass.</p> <pre><code># Create all data on constructor (miscroscope settings and channels)\nfactory = MetadataFactory([{\"name\": \"Channel1\", \"color\": \"red\"},\n                           {\"name\": \"Channel2\", \"color\": \"blue\", \"immersion_refractive_index\" : 1.2}],\n                          pixel_calibration = 50,\n                          objective_magnification = 40.0)\n\nprint(factory.createMetadata())\n</code></pre> <p>You can also create factory instance with global microscope settings and add channels later.</p> <pre><code># Create factory instance with global microscope settings\nfactory = MetadataFactory(immersion_refractive_index= 1.5,\n                        objective_magnification= 40.0, pixel_calibration=20)\n</code></pre> <p>You can add channel using named arguments. <pre><code>factory.addPlane(name = \"Channel 1\",\n                 emission_wavelength = 500,\n                 color = \"blue\")\n</code></pre> You can add channel using <code>Plane</code> dataclass. <pre><code>factory.addPlane(Plane(name = \"Channel 2\",\n                       excitation_wavelength = 600,\n                       emission_wavelength = 700,\n                       color = \"blue\"))\n</code></pre></p> <p>Or you can add channels using a dictionary. <pre><code>factory.addPlane({\"name\": \"Channel 3\",\n                \"immersion_refractive_index\": 1.6,\n                \"objective_magnification\": 20.0})\n</code></pre></p> <p>You can also create channel, store it in a variable and modify it. <pre><code>plane = factory.addPlane({\"name\": \"Channel 4\"})\n\nplane.color = \"green\"\nplane.camera_name = \"Camera channel 4\"\nplane.modality = \"Brightfield\"\n</code></pre></p> <p>Or you can access existing channel using its index</p> <pre><code>factory.getChannel(2).pinhole_diameter = 50\nfactory.getChannel(2).microscope_name = \"Microscope for channel 3\"\nfactory.getChannel(2).color = \"green\"\n</code></pre> <p>Or you can access existing channel using its channel name</p> <pre><code>factory.getChannel(\"Channel 1\").color = \"red\"\nfactory.getChannel(\"Channel 1\").immersion_refractive_index = 1.6\n</code></pre> <p>Finally create metadata using createMetadata method <pre><code>print(factory.createMetadata())\n</code></pre></p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; PictureMetadata\n</code></pre> <p>Creates a new PictureMetadata instance from the factory settings.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.addPlane","title":"addPlane","text":"<pre><code>addPlane(plane: Plane | dict[str, Any] = None, **kwargs) -&gt; Plane\n</code></pre> <p>Adds a new channel to the factory, see examples on how to use this method and <code>Plane</code> dataclass to see what settings can be applied.</p> PARAMETER DESCRIPTION <code>plane</code> <p>A <code>Plane</code> object or a dictionary with plane settings.</p> <p> TYPE: <code>Plane | dict[str, Any]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional settings for the plane.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.createMetadata","title":"createMetadata","text":"<pre><code>createMetadata(*, number_of_channels_fallback: int = 1, is_rgb_fallback: bool = False) -&gt; PictureMetadata\n</code></pre> <p>Creates a new PictureMetadata instance from the factory settings.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.Plane","title":"Plane  <code>dataclass</code>","text":"<pre><code>Plane(*, name: str = None, modality: str | PicturePlaneModality | PicturePlaneModalityFlags = None, excitation_wavelength: int = None, emission_wavelength: int = None, color: str = None, objective_magnification: float = None, objective_numerical_aperture: float = None, zoom_magnification: float = None, immersion_refractive_index: float = None, pinhole_diameter: float = None, camera_name: str = None, microscope_name: str = None, filter_name: str = None, acquisition_time: datetime = None)\n</code></pre> <p>A class to represent a plane in metadata, see attributes list to see what settings can be applied.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>The name of the plane.</p> <p> TYPE: <code>str</code> </p> <code>modality</code> <p>The modality of the plane, can be a string (e.g., fluorescence, brightfield) or an instance of PicturePlaneModality or PicturePlaneModalityFlags.</p> <p> TYPE: <code>str | PicturePlaneModality | PicturePlaneModalityFlags</code> </p> <code>excitation_wavelength</code> <p>The excitation wavelength in nanometers.</p> <p> TYPE: <code>int</code> </p> <code>emission_wavelength</code> <p>The emission wavelength in nanometers.</p> <p> TYPE: <code>int</code> </p> <code>filter_name</code> <p>The name of the filter used.</p> <p> TYPE: <code>str</code> </p> <code>color</code> <p>The color associated with the plane.</p> <p> TYPE: <code>str</code> </p> <code>objective_magnification</code> <p>The magnification of the objective lens. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>float</code> </p> <code>objective_numerical_aperture</code> <p>The numerical aperture of the objective lens. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>float</code> </p> <code>zoom_magnification</code> <p>The zoom magnification. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>float</code> </p> <code>immersion_refractive_index</code> <p>The refractive index of the immersion medium. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>float</code> </p> <code>pinhole_diameter</code> <p>The diameter of the pinhole. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>float</code> </p> <code>camera_name</code> <p>The name of the camera used. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>str</code> </p> <code>microscope_name</code> <p>The name of the microscope used. (overrides setting from MetadataFactory)</p> <p> TYPE: <code>str</code> </p> <code>acquisition_time</code> <p>Acquistion time of the plane.</p> <p> TYPE: <code>datetime</code> </p>"},{"location":"nd2/","title":"Nd2 module","text":""},{"location":"nd2/#limnd2.nd2.Nd2Base","title":"Nd2Base","text":""},{"location":"nd2/#limnd2.nd2.Nd2Base.last_modified","title":"last_modified  <code>property</code>","text":"<pre><code>last_modified: datetime\n</code></pre> <p>Returns the modify time of the file on disk.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Base.size_on_disk","title":"size_on_disk  <code>property</code>","text":"<pre><code>size_on_disk: int\n</code></pre> <p>Returns the number of bytes the file takes on disk.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Base.version","title":"version  <code>property</code>","text":"<pre><code>version: tuple[int, int]\n</code></pre> <p>Returns the version of the <code>.nd2</code> file as a tuple of two integers.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader","title":"Nd2Reader","text":"<pre><code>Nd2Reader(file: FileLikeObject, *, chunker_kwargs: dict = {})\n</code></pre> <p>Creates Nd2Read instance for reading <code>.nd2</code> files and its attributes, metadata, properties, image data and so on.</p> <p>Also see Quickstart for an example of how to use this class and how to read individual chunks, attributes, metadata and so on.</p> PARAMETER DESCRIPTION <code>file</code> <p>Filename of the ND2 file.</p> <p> TYPE: <code>str | Path | int | BinaryIO</code> </p> <code>chunker_kwargs</code> <p>Additional parameters for chunker.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.experiment","title":"experiment  <code>property</code>","text":"<pre><code>experiment: ExperimentLevel | None\n</code></pre> <p>Attribute to get experiments in an <code>.nd2</code> file.</p> <p>See <code>ExperimentLevel</code> class for more information.</p> <p>In order to create an instance of <code>ExperimentLevel</code> class, use <code>ExperimentFactory</code> class.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.generalImageInfo","title":"generalImageInfo  <code>cached</code> <code>property</code>","text":"<pre><code>generalImageInfo: dict[str, any]\n</code></pre> <p>Returns general information about the image as a dictionary.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.imageAttributes","title":"imageAttributes  <code>property</code>","text":"<pre><code>imageAttributes: ImageAttributes\n</code></pre> <p>Attribute to get attributes of an <code>.nd2</code> file.</p> <p>See <code>ImageAttributes</code> class for more information.</p> <p>In order to create an instance of <code>ImageAttributes</code> class from simple parameters, use <code>ImageAttributes.create</code> method.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.is3d","title":"is3d  <code>cached</code> <code>property</code>","text":"<pre><code>is3d: bool\n</code></pre> <p>Returns <code>True</code> if the file contains valid z-stack, otherwise <code>False</code>.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.is8bitRgb","title":"is8bitRgb  <code>cached</code> <code>property</code>","text":"<pre><code>is8bitRgb: bool\n</code></pre> <p>Returns <code>True</code> if the file contains 8-bit RGB data, otherwise <code>False</code>.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.isFloat","title":"isFloat  <code>cached</code> <code>property</code>","text":"<pre><code>isFloat: bool\n</code></pre> <p>Returns <code>True</code> if the file data is 32-bit float, otherwise <code>False</code>.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.isMono","title":"isMono  <code>cached</code> <code>property</code>","text":"<pre><code>isMono: bool\n</code></pre> <p>Returns <code>True</code> if the file contains only one component, otherwise <code>False</code>.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.isRgb","title":"isRgb  <code>cached</code> <code>property</code>","text":"<pre><code>isRgb: bool\n</code></pre> <p>Returns <code>True</code> if the file contains RGB data, otherwise <code>False</code>.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.pictureMetadata","title":"pictureMetadata  <code>property</code>","text":"<pre><code>pictureMetadata: PictureMetadata\n</code></pre> <p>Attribute to get metadata of an <code>.nd2</code> file.</p> <p>See <code>PictureMetadata</code> class for more information.</p> <p>In order to create an instance of <code>PictureMetadata</code> class, use <code>MetadataFactory</code> class.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.results","title":"results  <code>cached</code> <code>property</code>","text":"<pre><code>results: dict[str, ResultItem]\n</code></pre> <p>Returns a dictionary of all results in the accompanying <code>.h5</code> file.</p> <p>Each result potentially contains tabular results (tables, graphs, ...) and binary layers.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.chunk","title":"chunk","text":"<pre><code>chunk(name: bytes | str) -&gt; bytes | memoryview | None\n</code></pre> <p>Returns data for specific chunk name</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the chunk to retrieve.</p> <p> TYPE: <code>bytes | str</code> </p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.crestDeepSimRawData","title":"crestDeepSimRawData","text":"<pre><code>crestDeepSimRawData(seqindex: int, component_index: int) -&gt; NumpyArrayLike\n</code></pre> <p>This method retrieves deepSIM data for a specific sequence index and component.</p> <p>The data is returned as a tuple containing deepSIM data (see <code>Returns</code> section below).</p> <p>Warning</p> <p>Even if file contains deepSIM data, not all channels or sequence indices must have deepSim data, use <code>crestDeepSimRawDataIndices()</code> method to see all valid indices for deepSIM data.</p> <p>Reading all deepSIM data can be done using following code: <pre><code>file = \"deepSIM.nd2\"\n\nwith limnd2.Nd2Reader(file) as nd2:\n    results = {}\n    for indices in nd2.crestDeepSimRawDataIndices():\n        results[indices] = nd2.crestDeepSimRawData(*indices)\n\n    for i, r in results.items():\n        print(f\"Input indices: sequence index: {i[0]}, component index: {i[1]}\")\n        print(\"    Final image: (shape)\", r[0].shape)\n        print(\"    Calibration key:\", r[1])\n        print(\"    Calibration data: (length of XML)\", len(r[2]))\n        print(\"    PSF: (set, default)\", r[3])\n        print(\"    Iter: (set, default)\", r[4])\n        print(\"    ROI offsets: (x, y)\", r[5])\n</code></pre></p> See example output <pre><code>Input indices: sequence index: 0, component index: 0\n    Final image: (shape) (65, 1024, 1024)\n    Calibration key: zoom60000_na1400_ex561_pitch15000_size1500_im65_tm0\n    Calibration data: (length of XML) 880341\n    PSF: (set, default) (2.0, 2.0)\n    Iter: (set, default) (25, 25)\n    ROI offsets: (x, y) (0, 0)\nInput indices: sequence index: 0, component index: 1\n    Final image: (shape) (65, 1024, 1024)\n    Calibration key: zoom60000_na1400_ex488_pitch15000_size1500_im65_tm0\n    Calibration data: (length of XML) 884538\n    PSF: (set, default) (2.0, 2.0)\n    Iter: (set, default) (25, 25)\n    ROI offsets: (x, y) (0, 0)\nInput indices: sequence index: 1, component index: 0\n    Final image: (shape) (65, 1024, 1024)\n...\n</code></pre> PARAMETER DESCRIPTION <code>seqindex</code> <p>The index of the sequence for which the deepSIM data is being retrieved.</p> <p> TYPE: <code>int</code> </p> <code>component_index</code> <p>The index of the component for which the deepSIM data is requested.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>A 3D array of deepSIM image data with shape (channel_count, height, width).</p> <code>str</code> <p>A string that contains the significant calibration data in compressed form, for example <code>zoom60000_na1400_ex561_pitch15000_size1500_im65_tm0</code>.</p> <code>str</code> <p>DeepSIM data detailed outcome in XML Format as string.</p> <code>tuple[float, float]</code> <p>PSF values (used, default). Depends on the objective used.</p> <code>tuple[int, int]</code> <p>Number of iterations for reconstruction (used, default).</p> <code>tuple[int, int]</code> <p>ROI width and height listed in ndarray (x, y).</p> RAISES DESCRIPTION <code>NameNotInChunkmapError</code> <p>If chunk with given sequence and component index is missing.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.crestDeepSimRawDataIndices","title":"crestDeepSimRawDataIndices","text":"<pre><code>crestDeepSimRawDataIndices() -&gt; list[tuple[int, int]]\n</code></pre> <p>Returns all valid indices for deepSIM data in the <code>.nd2</code> file.</p> <p>Indices are returned as tuples of (sequence_index, component_index) in a list.</p> <p>See <code>crestDeepSimRawData()</code> method that uses those indices to retrieve deepSIM data.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.generateLoopIndexes","title":"generateLoopIndexes","text":"<pre><code>generateLoopIndexes(named: bool = False) -&gt; list\n</code></pre> <p>Generates indexes for all loops in the experiment.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.image","title":"image","text":"<pre><code>image(seqindex: int, rect: tuple[int, int, int, int] | None = None) -&gt; NumpyArrayLike\n</code></pre> <p>Get image data from specified frame as NumPy array.</p> PARAMETER DESCRIPTION <code>seqindex</code> <p>Image sequence index you want to get.</p> <p> TYPE: <code>int</code> </p> <code>rect</code> <p>Rectangle (x, y, w, h) of the image to get image to get.</p> <p> TYPE: <code>tuple[int, int, int, int] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.result_size_on_disk","title":"result_size_on_disk","text":"<pre><code>result_size_on_disk(result_name: str) -&gt; int | None\n</code></pre> <p>Returns size of the result.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer","title":"Nd2Writer","text":"<pre><code>Nd2Writer(file: FileLikeObject, *, append: bool | None = None, chunker_kwargs: dict = {})\n</code></pre> <p>Experimental ND2 file writer.</p> <p>Supports encoding od all image attributes, most commonly used experiments and most of image metadata. Currently does not support encoding of Well-plates, binary layers, ROIs and any custom data and text into chunk.</p> <p>Info</p> <p>Data is written in chunks, so you can write data in any order you want, image data however can only be written after image attributes are set, if you write same chunk multiple times, all chunks will be saved, however only the last one will be used.</p> <p>Tip</p> <p>As explained in Quickstart, image data can only be written after image attributes are set, but if you want to write image data into <code>.nd2</code> file without knowing how many frames there is (for example with continuous writing), you can pass <code>ImageAttributes</code> instance when creating <code>.nd2</code> using custom chunker argument as shown below.</p> <p>Setting <code>ImageAttributes</code> this way will not store them in <code>.nd2</code> file and you still have to store them at some point, however you can do so after you know how many frames there is.</p> Example os using chunker arguments to set image attributes<pre><code>attributes = limnd2.attributes.ImageAttributes.create(\n    width = WIDTH,\n    height = HEIGHT,\n    component_count = COMPONENT_COUNT,\n    bits = BITS,\n    sequence_count = ...  # will be set later\n)\n\nwith limnd2.Nd2Writer(\"outfile.nd2\", chunker_kwargs={\"with_image_attributes\": attributes}) as nd2:\n    # you can now set image data without setting attributes\n</code></pre> <p>See Quickstart for an example of how to use this class and how to write individual chunks.</p> PARAMETER DESCRIPTION <code>file</code> <p>Filename of the ND2 file.</p> <p> TYPE: <code>str | Path | int | BinaryIO</code> </p> <code>chunker_kwargs</code> <p>Additional parameters for chunker.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.experiment","title":"experiment  <code>property</code> <code>writable</code>","text":"<pre><code>experiment: ExperimentLevel\n</code></pre> <p>Attribute to get or set experiments in an <code>.nd2</code> file.</p> <p>See <code>ExperimentLevel</code> class for more information.</p> <p>In order to create an instance of <code>ExperimentLevel</code> class, use <code>ExperimentFactory</code> class.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.imageAttributes","title":"imageAttributes  <code>property</code> <code>writable</code>","text":"<pre><code>imageAttributes: ImageAttributes\n</code></pre> <p>Attribute to get or set attributes of an <code>.nd2</code> file.</p> <p>See <code>ImageAttributes</code> class for more information.</p> <p>In order to create an instance of <code>ImageAttributes</code> class from simple parameters, use <code>ImageAttributes.create</code> method.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.pictureMetadata","title":"pictureMetadata  <code>property</code> <code>writable</code>","text":"<pre><code>pictureMetadata: PictureMetadata\n</code></pre> <p>Attribute to get or set metadata of an <code>.nd2</code> file.</p> <p>See <code>PictureMetadata</code> class for more information.</p> <p>In order to create an instance of <code>PictureMetadata</code> class, use <code>MetadataFactory</code> class.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.finalize","title":"finalize","text":"<pre><code>finalize() -&gt; None\n</code></pre> <p>Explicitly finalize the file, this is not needed if you use <code>with</code> statement.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.setImage","title":"setImage","text":"<pre><code>setImage(seq_index: int, data: NumpyArrayLike) -&gt; None\n</code></pre> <p>Seta image data using specified frame index.</p> <p>Warning</p> <p>You must manually keep track of the frame index and make sure that you are not overwriting the same frame multiple times and that images are written sequentially.</p>"},{"location":"nd2file/","title":"Nd2File","text":"<p>This file serves as a compatibility layer between the limnd2 library by Laboratory Imaging s.r.o. and the nd2 library by Harvard Medical School microscopist Talley Lambert.</p> <p>It is designed for users familiar with Talley Lambert's <code>nd2</code> library, providing a seamless transition by mimicking its interface while utilizing the <code>limnd2</code> library as the underlying implementation.</p> <p>We extend our heartfelt thanks to Talley Lambert for his outstanding work on the <code>nd2</code> library, which has greatly benefited the imaging community, and for his invaluable input in helping us develop the <code>limnd2</code> library.</p> <p>Under Development</p> <p>This feature is under development. Only some methods are currently supported and sometimes only partially.</p>"},{"location":"nd2file/#limnd2.nd2file.ND2File","title":"ND2File","text":"<pre><code>ND2File(path: FileOrBinaryIO, *, validate_frames: bool = False, search_window: int = 100)\n</code></pre>"},{"location":"nd2file/#limnd2.nd2file.ND2File.attributes","title":"attributes  <code>cached</code> <code>property</code>","text":"<pre><code>attributes: Attributes\n</code></pre> <p>works</p>"},{"location":"nd2file/#limnd2.nd2file.ND2File.experiment","title":"experiment  <code>cached</code> <code>property</code>","text":"<pre><code>experiment: list[ExpLoop]\n</code></pre> <p>works for T, M, Z experiments</p>"},{"location":"nd2file/#limnd2.nd2file.ND2File.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>works</p>"},{"location":"nd2file/#limnd2.nd2file.ND2File.version","title":"version  <code>cached</code> <code>property</code>","text":"<pre><code>version: tuple[int, ...]\n</code></pre> <p>works</p>"}]}