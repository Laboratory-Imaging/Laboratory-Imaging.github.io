{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"limnd2 package","text":"<p>Warning</p> <p>This Python package is not yet available for the public, both the package and the documentation is still being worked on.</p> <p><code>.nd2</code> (Nikon NIS Elements) file reader and writer in Python.</p>"},{"location":"#installation","title":"Installation","text":"PyPIManual (Windows)Manual (Linux) <p>Warning</p> <p>This Python package is not released on PyPI yet, use manual installation.</p> <p>You can install this package from PyPI by running following command:</p> <pre><code>pip install limnd2\n</code></pre> <p>Run following commands in a folder where you want to install this package.</p> <pre><code>git clone https://github.com/Laboratory-Imaging/limnd2.git\ncd limnd2\npython -m venv env\nenv\\Scripts\\activate\npython -m pip install --upgrade pip\npip install -r requirements.txt\n</code></pre> <p>Run following commands in a folder where you want to install this package.</p> <pre><code>git clone https://github.com/Laboratory-Imaging/limnd2.git\ncd limnd2\npython3 -m venv env\nsource env/bin/activate\npython3 -m pip install --upgrade pip\npip install -r requirements.txt\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#reading-nd2-files","title":"Reading <code>.nd2</code> files","text":"<p>An example Python file showcasing how to read an <code>.nd2</code> file with this library is found at GitHub repo for this page: example_reader.py.</p>"},{"location":"#opening-nd2-file","title":"Opening <code>.nd2</code> file","text":"<p>An <code>.nd2</code> file can be opened using <code>Nd2Reader</code> class like this:</p> <pre><code>nd2 = limnd2.Nd2Reader(\"file.nd2\")\n</code></pre> <p>However it is recommended to open <code>.nd2</code> files (especially when writing) using <code>with</code> statement to automatically close the file.</p> example_reader.py<pre><code>with limnd2.Nd2Reader(\"file.nd2\") as nd2:\n</code></pre>"},{"location":"#getting-summary-information","title":"Getting summary information","text":"<p>Quick access to information about the file can be gained with <code>generalImageInfo</code> dictionary:</p> example_reader.py<pre><code>print(\"Summary information\")\nfor key, value in nd2.generalImageInfo.items():\n    print(f\"{key}: {value}\")\n</code></pre> See example output <pre><code>Summary information\nfilename: file.nd2\npath: C:\\Users\\user\\Desktop\\nd2_files\nbit_depth: 32bit float\nloops: XY(25), Z(5)\ndimension: 1024 x 1024 (2 comps 32bit float) x 125 frames: XY(25), Z(5)\nfile_size: 6732537856\nframe_res: 1024 x 1024\nvolume_size: 40MB\nsizes: 6GB on disk, 8MB frame, 40MB volume\ncalibration: 0.432 \u00b5m/px\nmtime: 06/07/21 14:17:56\napp_created: NIS-Elements AR 5.20.00 (Build 1423)\n</code></pre>"},{"location":"#getting-text-information","title":"Getting text information","text":"<p>More information about components can be in <code>imageTextInfo</code> dataclass, though this information is stored as a string:</p> example_reader.py<pre><code>print(\"More information\")\nfor key, value in nd2.imageTextInfo.to_dict().items():\n    print(f\"{key}: {value}\")\n</code></pre> See example output <pre><code>More information\nimageId:\ntype:\ngroup:\nsampleId:\nauthor:\ndescription: Metadata:\nDimensions: XY(25) x Z(5)\nCamera Name: Nikon A1 LFOV\nNumerical Aperture: 1.15\nRefractive Index: 1.333\nNumber of Picture Planes: 2\nPlane #1:\n    Name: DETECTOR A\n    Component Count: 1\n    Modality: AUX\n    Microscope Settings:   Microscope: Ti2 Microscope\n    External Phase, position: 0\n    Polarizer, position: Out\n    DIC Prism, position: In\n    Bertrand Lens, position: Out\n    Nikon Ti2, FilterChanger(Turret-Lo): 1 (Empty)\n    Nikon Ti2, FilterChanger(Turret-Up): 1 (Empty)\n    Nikon Ti2, Shutter(FL-Lo): Closed\n    Nikon Ti2, Shutter(FL-Up): Closed\n    LightPath: L100\n    Analyzer Slider: Extracted\n    Condenser: 3 (OPEN)\n    PFS, state: Off\n    PFS, offset: 5700\n    PFS, mirror: Inserted\n    PFS, Dish Type: Glass\n    Zoom: 1.00x\n    Eyepiece Ports:\n        Port 1: Off  (Camera)\n        Port 2: On  (Eye)\n\n    LAPP Upper Ports:\n        Port 1: Off  (1)\n        Port 2: On  (2)\n\n    LAPP Lower Ports:\n        Port 1: Off  (H-TIRF Direct XY-F)\n        Port 2: Off  (2)\n        Port 3: On  (3)\n\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    E-TIRF1 Angle: 0.0\n    E-TIRF1 Direction: 0.0\n    NIDAQ, FilterChanger(FilterWheel): 1 (Empty)\n    NIDAQ, Shutter(LUN-F): Closed\n    NIDAQ, Shutter(LUN4): Closed\n    NIDAQ, Shutter(AUX1): Closed\n    NIDAQ, Shutter(EPI): Closed\n    NIDAQ, MultiLaser(LUN-F):\n        Line:1; ExW:405; Power: 34.8; On\n\n    NIDAQ, MultiLaser(LUN4):\n        Line:1; ExW:405; Power: 30.0; Off\n        Line:2; ExW:488; Power: 30.0; Off\n        Line:3; ExW:561; Power: 30.0; On\n        Line:4; ExW:640; Power: 30.0; Off\n\nPlane #2:\n    Name: DETECTOR B\n    Component Count: 1\n    Modality: AUX\n    Microscope Settings:   Microscope: Ti2 Microscope\n    External Phase, position: 0\n    Polarizer, position: Out\n    DIC Prism, position: In\n    Bertrand Lens, position: Out\n    Nikon Ti2, FilterChanger(Turret-Lo): 1 (Empty)\n    Nikon Ti2, FilterChanger(Turret-Up): 1 (Empty)\n    Nikon Ti2, Shutter(FL-Lo): Closed\n    Nikon Ti2, Shutter(FL-Up): Closed\n    LightPath: L100\n    Analyzer Slider: Extracted\n    Condenser: 3 (OPEN)\n    PFS, state: Off\n    PFS, offset: 5700\n    PFS, mirror: Inserted\n    PFS, Dish Type: Glass\n    Zoom: 1.00x\n    Eyepiece Ports:\n        Port 1: Off  (Camera)\n        Port 2: On  (Eye)\n\n    LAPP Upper Ports:\n        Port 1: Off  (1)\n        Port 2: On  (2)\n\n    LAPP Lower Ports:\n        Port 1: Off  (H-TIRF Direct XY-F)\n        Port 2: Off  (2)\n        Port 3: On  (3)\n\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    H-TIRF  X: 0.0\n    H-TIRF  Y: 0.0\n    H-TIRF  Focus: 0.0\n    E-TIRF1 Angle: 0.0\n    E-TIRF1 Direction: 0.0\n    NIDAQ, FilterChanger(FilterWheel): 1 (Empty)\n    NIDAQ, Shutter(LUN-F): Closed\n    NIDAQ, Shutter(LUN4): Closed\n    NIDAQ, Shutter(AUX1): Closed\n    NIDAQ, Shutter(EPI): Closed\n    NIDAQ, MultiLaser(LUN-F):\n        Line:1; ExW:405; Power: 34.8; On\n\n    NIDAQ, MultiLaser(LUN4):\n        Line:1; ExW:405; Power: 30.0; Off\n        Line:2; ExW:488; Power: 30.0; Off\n        Line:3; ExW:561; Power: 30.0; On\n        Line:4; ExW:640; Power: 30.0; Off\n\nZ Stack Loop: 5\n- Step: 4 \u00b5m\n- Device: Ti2 ZDrive\ncapturing: Nikon A1 LFOV\n\nsampling:\nlocation:\ndate: 9/22/2068  12:28:28 AM\nconclusion:\ninfo1:\ninfo2:\noptics: Apo LWD 40x WI \u03bbS DIC N2\n</code></pre>"},{"location":"#getting-image-attributes","title":"Getting image attributes","text":"<p>Image attributes dataclass mostly contains information about dimensions of an image like width and height, number of components and number of frames in nd2 file.</p> <p>For all properties and methods of this dataclass see attributes.py.</p> <p>To get image attributes use <code>imageAttributes</code> attribute of <code>Nd2Reader</code> instance created in previous step.</p> example_reader.py<pre><code>attributes = nd2.imageAttributes\n</code></pre> <p>Then you can use following properties to get information about the file:</p> example_reader.py<pre><code>print(f\"Image resolution: {attributes.width} x {attributes.height}\")\nprint(f\"Number of components: {attributes.componentCount}\")\nprint(f\"Number of frames: {attributes.frameCount}\")\nprint(f\"Image size (in bytes): {attributes.imageBytes}\")\nprint(f\"Python data type: {attributes.dtype}\")\n</code></pre> See example output <pre><code>Image resolution: 1024 x 1024\nNumber of components: 2\nNumber of frames: 125\nImage size (in bytes): 8388608\nPython data type: &lt;class 'numpy.float32'&gt;\n</code></pre>"},{"location":"#getting-image-data","title":"Getting image data","text":"<p>This library uses NumPy arrays to store image data found in the <code>.nd2</code> file, if you want to access image data itself, you can do so by using <code>.image()</code> method with index of the image you want to get like this:</p> example_reader.py<pre><code>image = nd2.image(0)        # get first image\nprint(type(image))\nprint(\"Numpy array shape:\", image.shape, \"stored datatype:\", image.dtype)\n</code></pre> See example output <pre><code>&lt;class 'numpy.ndarray'&gt;\nNumpy array shape: (1024, 1024, 2) stored datatype: float32\n</code></pre> <p>If you want to get all images in the <code>.nd2</code> file, use a for loop with <code>frameCount</code> property from image attributes.</p> example_reader.py<pre><code>images = []\nfor i in range(attributes.frameCount):\n    images.append(nd2.image(i))\nprint(f\"Obtained {len(images)} frames.\")\n</code></pre> See example output <pre><code>Obtained 125 frames.\n</code></pre>"},{"location":"#getting-experiment-data","title":"Getting experiment data","text":"<p>Experiments in <code>.nd2</code> files define how image sequences are organized and looped. The most common types of loops include:</p> <ul> <li>Time Loop (<code>timeloop</code>): A sequence of images captured over time.</li> <li>Z-Stack (<code>zstack</code>): Frames stacked along the z-axis, representing different focal planes.</li> <li>Multi-Point (<code>multipoint</code>): Images captured at multiple specified locations (points) with known coordinates.</li> </ul> <p>An image can have no experiment, a single experiment, or a combination of multiple experiments.</p> <p>To obtain data structure with information about used experiments, use <code>experiment</code> property.</p> example_reader.py<pre><code>experiment = nd2.experiment\n</code></pre> <p>Then to see what kind of experiment <code>.nd2</code> file contains, you can iterate over this data structure with a for loop:</p> example_reader.py<pre><code>print(\"Experiment loops in image:\")\nfor e in experiment:\n    print(f\"Experiment name: {e.name}, number of frames: {e.count}\")\n</code></pre> See example output <pre><code>Experiment loops in image:\nExperiment name: Multipoint, number of frames: 25\nExperiment name: Z-Stack, number of frames: 5\n</code></pre> <p>Now if we want to access attributes and methods for specific loop type, we can use .findLevel() method with ExperimentLoopType type as parameter, in this example we search for Z-Stack experiment = use value ExperimentLoopType.eEtZStackLoop.</p> <p>Then we can access data for this experiment through parameters of this experiment, in this example we use attributes and properties of ExperimentZStackLoop.</p> example_reader.py<pre><code>zstack = experiment.findLevel(limnd2.ExperimentLoopType.eEtZStackLoop)\n\nprint(\"Distance between frames:\", zstack.uLoopPars.dZStep, \"\u03bcm\")\nprint(\"Home index:\", zstack.uLoopPars.homeIndex)\nprint(\"Top position:\", zstack.uLoopPars.top, \"\u03bcm\")\nprint(\"Bottom position:\", zstack.uLoopPars.bottom, \"\u03bcm\")\n</code></pre> See example output <pre><code>Distance between frames: 4.0 \u03bcm\nHome index: 2\nTop position: 5.0 \u03bcm\nBottom position: -5.0 \u03bcm\n</code></pre> <p>For all attributes of all experiments type look into experiment.py</p>"},{"location":"#getting-metadata","title":"Getting metadata","text":"<p>Metadata in <code>.nd2</code> file contain a lot of additional data about the image, especially about planes, this information includes:</p> <ul> <li>plane name</li> <li>modality</li> <li>filter path</li> <li>sample settings</li> <li>fluorescent probe</li> <li>much more, see metadata.py for full information about <code>.nd2</code> metadata</li> </ul> <p>To get metadata, use <code>pictureMetadata</code> attribute like this:</p> example_reader.py<pre><code>metadata = nd2.pictureMetadata\n</code></pre> <p>To iterate over planes in the image, you can use <code>.channels()</code> method from the metadata that just were created, then <code>.sampleSettings()</code> method to get sample settings for given plane.</p> <p>With channel and settings stored in separate variables, you can then access selected attributes like this:</p> example_reader.py<pre><code>for channel in metadata.channels:\n    settings = metadata.sampleSettings(channel)\n    print(\"Channel name:\", channel.sDescription)\n    print(\" Modality:\", \" \".join(limnd2.metadata.PicturePlaneModalityFlags.to_str_list(channel.uiModalityMask)))\n    print(\" Emission wavelength:\", channel.emissionWavelengthNm)\n    print(\" Excitation wavelength:\", channel.excitationWavelengthNm)\n\n    print(\" Camera name\", settings.cameraName)\n    print(\" Microscope name\", settings.microscopeName)\n    print(\" Objective magnification\", settings.objectiveMagnification)\n    print()\n</code></pre> See example output <pre><code>Channel name: DETECTOR A\n Modality: Camera AUX\n Emission wavelength: 520.0\n Excitation wavelength: 488.0\n Camera name Nikon A1 LFOV\n Microscope name Ti2 Microscope\n Objective magnification 40.0\n\nChannel name: DETECTOR B\n Modality: Camera AUX\n Emission wavelength: 650.0\n Excitation wavelength: 488.0\n Camera name Nikon A1 LFOV\n Microscope name Ti2 Microscope\n Objective magnification 40.0\n</code></pre>"},{"location":"#getting-other-data","title":"Getting other data","text":"<p>Attributes, experiments, metadata, and image data are the most important parts of an .nd2 file, which is why they were the focus of this guide. The limnd2 module can also access information about binary layers, ROIs, and other data stored in the file. However, at this time, we do not provide a guide on how to read these additional components.</p> <p>If this causes any issues or you need further clarification, please feel free to head over to the Discussion page on our GitHub repository and let us know.</p>"},{"location":"#writing-to-nd2-file","title":"Writing to <code>.nd2</code> file","text":"<p>This package also allows you to write into and create <code>.nd2</code> files, an example of how to do this, you can look into example_writer.py, which will also be described below.</p> <p>In the example below we will create new <code>.nd2</code> file with preset width, height, bits per component, component count and sequence count. Instead of using actual image data we will use NumPy to generate arrays filled with random noise, which we will store in the result file.</p> <p>Here are the settings that will be used to generate image attributes and NumPy arrays with image data.</p> example_writer.py<pre><code>WIDTH = 500\nHEIGHT = 200\nCOMPONENT_COUNT = 2\nBITS = 8\nSEQUENCE_COUNT = 10\n</code></pre> <p>We will also add 2 experiments in the file to showcase how Experiment creation works. We have 10 frames as defined above, we will split them into 5 timeloop indices and 2 Z-stack indices, we will also define step between frames on each axis:</p> example_writer.py<pre><code># timeloop experiment settings\nTIMELOOP_COUNT = 5\nTIMELOOP_STEP = 150\n\n# zstack experiment settings\nZSTACK_COUNT = 2\nZSTACK_STEP = 100\n</code></pre>"},{"location":"#opening-creating-nd2-file-for-writing","title":"Opening / creating <code>.nd2</code> file for writing","text":"<p>With constants defined, we can open <code>.nd2</code> file for reading using Nd2Writer class and <code>with</code> clause for automatic file closure.</p> example_writer.py<pre><code>with limnd2.Nd2Writer(\"outfile.nd2\") as nd2:\n</code></pre> <p>Warning</p> <p>If you are creating brand new <code>.nd2</code> files, make sure the filename does not already exist or delete such file if it does, <code>Nd2Writer</code> class can also write to existing files which may lead to unexpected results.</p>"},{"location":"#creating-and-writing-image-attributes","title":"Creating and writing image attributes","text":"<p>Image attributes can be created using <code>ImageAttributes.create()</code> method, we can simply assign those to <code>imageAttributes</code> property of <code>Nd2Writer</code>.</p> example_writer.py<pre><code>attributes = limnd2.attributes.ImageAttributes.create(\n    width = WIDTH,\n    height = HEIGHT,\n    component_count = COMPONENT_COUNT,\n    bits = BITS,\n    sequence_count = SEQUENCE_COUNT\n)\n\nnd2.imageAttributes = attributes\n</code></pre>"},{"location":"#creating-and-writing-image-data","title":"Creating and writing image data","text":"<p>Danger</p> <p>Image data can only be written after image attributes are set as the copy operation requires known NumPy array size.</p> <p>After writing image attributes, we can create random noise data and store them in the <code>.nd2</code> file, for this we will use <code>create_random_noise()</code> function (see <code>example_writer.py</code> for function definition) and send the result array to <code>setImage()</code> method.</p> <p>Important</p> <p>You must manually keep track of index or the image you are storing, also as we with with random noise, the order in which images are inserted does not matter, however the images must be inserted in correct order with respect to used experiments.</p> <p>This is especially important if you are converting multidimensional image sequence to <code>.nd2</code> file.</p> example_writer.py<pre><code>for i in range(SEQUENCE_COUNT):\n    nd2.setImage(i, create_random_noise(WIDTH, HEIGHT, COMPONENT_COUNT, BITS))\n</code></pre>"},{"location":"#creating-and-writing-experiments","title":"Creating and writing experiments","text":"<p>Experiments can be created using simplified experiment settings from <code>experiment_factory</code> module, each experiment is supplied with frame count and information relevant to given experiment, created instances are then converted into experiment using <code>experiment_factory.create_experiment()</code> function and the result is once again stored in writer instance.</p> example_writer.py<pre><code>texp = limnd2.experiment_factory.TExp(frame_count = TIMELOOP_COUNT,\n                                        time_delta = TIMELOOP_STEP)\n\nzexp = limnd2.experiment_factory.ZExp(frame_count = ZSTACK_COUNT,\n                                        stack_delta = ZSTACK_STEP)\n\nexperiment = limnd2.experiment_factory.create_experiment(texp, zexp)\n\nnd2.experiment = experiment\n</code></pre>"},{"location":"#creating-and-writing-metadata","title":"Creating and writing metadata","text":"<p>Metadata are created in similar way to experiments, also using simplified classes with the most important data. As there are 2 components, we will create one channel for each using <code>metadata.ChannelSettings</code>, we will add microscope using <code>metadata.MicroscopeSettings</code> and we will turn those simplified settings into metadata using <code>metadata.create_metadata()</code> function, the result of which we will assign into writer instance.</p> example_writer.py<pre><code>channel1 = limnd2.metadata.ChannelSettings(\n    name = \"Blue channel\",\n    modality = \"Confocal, Fluo\",\n    color = \"blue\"\n)\n\nchannel2 = limnd2.metadata.ChannelSettings(\n    name = \"Red channel\",\n    modality = \"Confocal, Fluo\",\n    color = \"red\"\n)\n\nmicroscope = limnd2.metadata.MicroscopeSettings(zoom_magnification = 200.0,\n                                                objective_magnification = 1.0,\n                                                pinhole_diameter = 50\n                                                )\n\nmetadata = limnd2.metadata.create_metadata(channels = [channel1, channel2],\n                                        pixel_calibration = 10.0,\n                                        microscope = microscope\n                                        )\n\nnd2.pictureMetadata = metadata\n</code></pre>"},{"location":"#saving-file","title":"Saving file","text":"<p>As we used <code>with</code> context manager, file is automatically saved and closed, if you did not use context manager, you need to manually call <code>.finalize()</code> method from <code>Nd2Writer</code> instance.</p> <p>With this done, you can now run the Python script and open the file in NIS Elements.</p>"},{"location":"#full-api-reference","title":"Full API reference","text":"<p>Here are the most important files in this library and an overview of what they contain:</p> <ul> <li>nd2.py - contains classes for opening ND2 files for reading and writing</li> <li>attributes.py - contains data structures about image attributes (width, height, component count, sequence count, ...)</li> <li>experiment.py - contains data structures about experiment loops (timeloop, z-stack, multipoint, ...)<ul> <li>experiment_factory.py - contains helpers for creating experiment data structure</li> </ul> </li> <li>metadata.py - contains data structures about image attributes (width, height, component count, sequence count, ...)</li> </ul> <p>Compatibility layer:</p> <ul> <li>nd2file.py - serves as a wrapper around limnd2 library to provide same interface to nd2 library by Talley Lambert</li> </ul>"},{"location":"#feedback","title":"Feedback","text":"<p>Did you find a bug? Do you have a question about this package or an idea for improvement? Join the discussion here.</p>"},{"location":"attributes/","title":"Attributes module","text":""},{"location":"attributes/#limnd2.attributes.ImageAttributes","title":"ImageAttributes  <code>dataclass</code>","text":"<p>Dataclass for ND2 Image attributes chunk, stores mostly information about image width, height, number of components and bit depth of each pixel, as well as information about compression and total number of images.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.componentBytes","title":"componentBytes  <code>property</code>","text":"<pre><code>componentBytes: int\n</code></pre> <p>Size of component in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.componentCount","title":"componentCount  <code>property</code>","text":"<pre><code>componentCount: int\n</code></pre> <p>Returns number of components in the image.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: NumpyDTypeLike\n</code></pre> <p>Returns numpy datatype used for storing image data in Python.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.frameCount","title":"frameCount  <code>property</code>","text":"<pre><code>frameCount: int\n</code></pre> <p>Returns number of frames in the ND2 file.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>Returns height of the image in pixels.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.imageBytes","title":"imageBytes  <code>property</code>","text":"<pre><code>imageBytes: int\n</code></pre> <p>Total size of the image in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.lowerPowSizeList","title":"lowerPowSizeList  <code>property</code>","text":"<pre><code>lowerPowSizeList: list[int]\n</code></pre> <p>Returns list of powers of 2 between ND2_MIN_DOWNSAMPLED_SIZE and image resolution.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.pixelBytes","title":"pixelBytes  <code>property</code>","text":"<pre><code>pixelBytes: int\n</code></pre> <p>Size of pixel in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.powSize","title":"powSize  <code>property</code>","text":"<pre><code>powSize: int\n</code></pre> <p>Returns next power of 2 for bigger dimension.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.powSizeBase","title":"powSizeBase  <code>property</code>","text":"<pre><code>powSizeBase: int\n</code></pre> <p>Returns exponent used in powSize() function.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.safe_dtype","title":"safe_dtype  <code>property</code>","text":"<pre><code>safe_dtype: NumpyDTypeLike\n</code></pre> <p>Returns numpy datatype that will always be big enough to fit pixel component data.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int, int]\n</code></pre> <p>Returns shape of the image which can be used with in array (height_pixels, width_pixels, component_count)</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.strides","title":"strides  <code>property</code>","text":"<pre><code>strides: tuple[int, int, int]\n</code></pre> <p>Returns the strides of the image which can be used in numpy array</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>Returns width of the image in pixels.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.widthBytes","title":"widthBytes  <code>property</code>","text":"<pre><code>widthBytes: int\n</code></pre> <p>Size of image row in bytes.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.calcWidthBytes","title":"calcWidthBytes  <code>staticmethod</code>","text":"<pre><code>calcWidthBytes(width: int, bits: int, comps: int) -&gt; int\n</code></pre> <p>Calculates number of bytes per single image row.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.create","title":"create  <code>staticmethod</code>","text":"<pre><code>create(width: int, height: int, component_count: int, bits: int, sequence_count: int) -&gt; ImageAttributes\n</code></pre> <p>Warning</p> <p>This function is used for creating new ImageAttributes instance, usually for creating new .nd2 files with Nd2Writer class.</p> <p>Create ImageAttributes instance from simplified parameters:</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>width in pixels</p> required <code>height</code> <code>int</code> <p>height in pixels</p> required <code>component_count</code> <code>int</code> <p>number of components</p> required <code>bits</code> <code>int</code> <p>number of bits per pixel component</p> required <code>sequence_count</code> <code>int</code> <p>total number of frames in ND2 file (product of size of each dimension)</p> required"},{"location":"attributes/#limnd2.attributes.ImageAttributes.from_lv","title":"from_lv  <code>staticmethod</code>","text":"<pre><code>from_lv(data: bytes | memoryview) -&gt; ImageAttributes\n</code></pre> <p>Decodes ImageAttributes from ND2 lite variant chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.from_var","title":"from_var  <code>staticmethod</code>","text":"<pre><code>from_var(data: bytes | memoryview) -&gt; ImageAttributes\n</code></pre> <p>Decodes ImageAttributes from ND2 XML chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.makeDownsampled","title":"makeDownsampled","text":"<pre><code>makeDownsampled(downsize: int | None = None) -&gt; ImageAttributes\n</code></pre> <p>Returns ImageAttributes for downsampled image using power of 2 image size.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.makeDownsampledFromPowBase","title":"makeDownsampledFromPowBase","text":"<pre><code>makeDownsampledFromPowBase(powBase: int) -&gt; ImageAttributes\n</code></pre> <p>Returns ImageAttributes for downsampled image using power of 2 exponent.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributes.to_lv","title":"to_lv","text":"<pre><code>to_lv() -&gt; bytes\n</code></pre> <p>Encodes ImageAttributes to ND2 lite variant chunk.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributesCompression","title":"ImageAttributesCompression","text":"<p>Enum for image compression.</p>"},{"location":"attributes/#limnd2.attributes.ImageAttributesPixelType","title":"ImageAttributesPixelType","text":"<p>Enum for pixel type.</p>"},{"location":"experiment/","title":"Experiment","text":"<p>This file is for experiments</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLevel","title":"ExperimentLevel  <code>dataclass</code>","text":"<p>               Bases: <code>LVSerializable</code></p> <p>Experiment Level</p>"},{"location":"experiment/#limnd2.experiment.ExperimentLoopType","title":"ExperimentLoopType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum specifiying which experiment type was used in <code>ExperimentLevel</code></p> <p>Attributes:</p> Name Type Description <code>eEtTimeLoop</code> <code>int</code> <p>Timeloop experiment</p> <code>eEtXYPosLoop</code> <code>int</code> <p>Multipoint experiment</p> <code>eEtZStackLoop</code> <code>int</code> <p>Z-stack experiment</p>"},{"location":"experiment_factory/","title":"Experiment factory module","text":"<p>This module contains helper classes and functions for creating <code>ExperimentLevel</code> instances using simplified parameters for each experiment type. Those instances should be used with <code>Nd2Writer</code> instance for altering / creating <code>.nd2</code> files.</p> <p>Info</p> <p>Since this module is used to creating experiment data structures, you should not use any part of this module if you only read an <code>.nd2</code> file.</p> <p>For creating experiments, you should use <code>ExperimentFactory</code> class.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory","title":"ExperimentFactory","text":"<p>Helper class for creating experiments, see examples below on how to create timeloop, multipoint and z-stack experiments either directly on factory constructor or by modifying values later.</p> <p>To actually create experiment instance, make sure to call either <code>.createExperiment()</code> method or use call operator.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory--sample-usage","title":"Sample usage","text":"<pre><code>from limnd2.experiment_factory import ExperimentFactory\n\n# only frame counts\nprint(ExperimentFactory(t=10, m=5).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(10 frames, interval: No Delay, duration: Continuous), Multipoint experiment(5 frames, point coordinates: [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0])</code></p> <pre><code># values from dict\nprint(ExperimentFactory(t={\"count\" : 3, \"step\": 350}, z={\"count\" : 5, \"step\": 150}).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: 0:00:00.350, duration: Continuous), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code># combination\nprint(ExperimentFactory(t=3, z={\"count\" : 5, \"step\": 150}).createExperiment())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: No Delay, duration: Continuous), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code># create factory and modify it\nfac = ExperimentFactory()\nfac.z.count = 10\nfac.z.step = 100\nprint(fac())            # createExperiment is called implicitly\n</code></pre> See example output <p><code>Z-Stack experiment(10 frames, step: 100.0)</code></p> <pre><code>fac = ExperimentFactory()\nfac.m.addPoint(10, 50)\nfac.m.addPoint(20, 70)\nprint(fac())\n</code></pre> See example output <p><code>Multipoint experiment(2 frames, point coordinates: [10.0, 50.0], [20.0, 70.0])</code></p> <pre><code># inlined multipoint\nprint(ExperimentFactory(t=3, z={\"count\" : 5, \"step\": 150}, m={\"count\" : 3, \"xcoords\" : [10,20,30], \"ycoords\" : [40,50,60]})())\n</code></pre> See example output <p><code>Timeloop experiment(3 frames, interval: No Delay, duration: Continuous), Multipoint experiment(3 frames, point coordinates: [10.0, 40.0], [20.0, 50.0], [30.0, 60.0]), Z-Stack experiment(5 frames, step: 150.0)</code></p> <pre><code>fac = ExperimentFactory()\nfac.t.count = 10\nfac.z.step = 100\nprint(fac())\n</code></pre> <p>Warning</p> <p>In this example Z-Stack experiment will be omitted from output since Z-stack frame count is not set, even though Z-stack step property was defined.</p> See example output <p><code>Timeloop experiment(10 frames, interval: No Delay, duration: Continuous)</code></p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; ExperimentLevel\n</code></pre> <p>Create <code>ExperimentLevel</code> instance using specified settings.</p>"},{"location":"experiment_factory/#limnd2.experiment_factory.ExperimentFactory.createExperiment","title":"createExperiment","text":"<pre><code>createExperiment() -&gt; ExperimentLevel\n</code></pre> <p>Create <code>ExperimentLevel</code> instance using specified settings.</p>"},{"location":"metadata/","title":"Metadata module","text":""},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes","title":"PictureMetadataPicturePlanes  <code>dataclass</code>","text":"<p>               Bases: <code>LVSerializable</code></p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.valid","title":"valid  <code>property</code>","text":"<pre><code>valid: bool\n</code></pre> <p>Checks if PictureMetadataPicturePlanes insance has valid number of channels.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if number of channels is valid, False otherwise.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.makeValid","title":"makeValid","text":"<pre><code>makeValid(comps: int, **kwargs) -&gt; None\n</code></pre> <p>Attempts to fix info about channels using specified number of channels.</p> <p>This function creates channel info basec on component count like this:</p> <p>comps = 1: function creates one Mono channel</p> <p>comps = 2: function creates channels Channel_1, Channel_2</p> <p>comps = 3: function creates one RGB channel</p> <p>comps &gt;= 4: function creates channels Channel_1 ... Channel_N</p> <p>Parameters:</p> Name Type Description Default <code>comps</code> <code>int</code> <p>The number of components in the image.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional parameters to pass to each plane.</p> <code>{}</code>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.to_serializable_dict","title":"to_serializable_dict","text":"<pre><code>to_serializable_dict(parent_path='')\n</code></pre> <p>Converts dataclass to Python dictionary encodeable with LV encoder.</p>"},{"location":"metadata/#limnd2.metadata.PictureMetadataPicturePlanes.to_table","title":"to_table","text":"<pre><code>to_table() -&gt; dict[str, any]\n</code></pre> <p>Converts picture planes metadata to a treeview table.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc","title":"PicturePlaneDesc  <code>dataclass</code>","text":"<p>               Bases: <code>LVSerializable</code></p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneDesc.to_serializable_dict","title":"to_serializable_dict","text":"<pre><code>to_serializable_dict(parent_path='')\n</code></pre> <p>Custom serialization for this object - \"sizeObjFullChip_cy\" has to be renamed to \"sizeObjFullChip.cy\"</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModality","title":"PicturePlaneModality","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for modality of given plane.</p> <p>Warning</p> <p>In modern .nd2 files this modality enum should be converted to PicturePlaneModalityFlags instance using from_modality() function.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags","title":"PicturePlaneModalityFlags","text":"<p>               Bases: <code>IntFlag</code></p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.from_modality","title":"from_modality  <code>staticmethod</code>","text":"<pre><code>from_modality(mod: PicturePlaneModality) -&gt; PicturePlaneModalityFlags\n</code></pre> <p>Converts modality enum to PicturePlaneModalityFlags.</p> <p>Parameters:</p> Name Type Description Default <code>mod</code> <code>PicturePlaneModality</code> <p>modality enum instance</p> required <p>Returns:</p> Type Description <code>PicturePlaneModalityFlags</code> <p>Modalify flag for given modality</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.from_modality_string","title":"from_modality_string  <code>staticmethod</code>","text":"<pre><code>from_modality_string(modality: str) -&gt; PicturePlaneModalityFlags\n</code></pre> <p>Converts modality string to PicturePlaneModalityFlags.</p> <p>Parameters:</p> Name Type Description Default <code>modality</code> <code>string</code> <p>modality string (for example \"Wide-field\", \"Brightfield\", \"Phase\", ...)</p> required <p>Returns:</p> Type Description <code>PicturePlaneModalityFlags</code> <p>Modalify flag for given modality, 0 for \"undefined\"</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.modality_list","title":"modality_list  <code>staticmethod</code>","text":"<pre><code>modality_list() -&gt; list[str]\n</code></pre> <p>Returns list of known modality strings (\"Wide-field\", \"Brightfield\", ...).</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.modality_string_map","title":"modality_string_map  <code>staticmethod</code>","text":"<pre><code>modality_string_map() -&gt; dict[str, PicturePlaneModalityFlags]\n</code></pre> <p>Returns mapping of known modality strings (\"Wide-field\", \"Brightfield\", ...) to PicturePlaneModalityFlags.</p>"},{"location":"metadata/#limnd2.metadata.PicturePlaneModalityFlags.to_str_list","title":"to_str_list  <code>staticmethod</code>","text":"<pre><code>to_str_list(flags: PicturePlaneModalityFlags) -&gt; list[str]\n</code></pre> <p>Converts modality flags to list of human readable strings.</p> <p>Parameters:</p> Name Type Description Default <code>flags</code> <code>PicturePlaneModalityFlags</code> <p>odality flags</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>human readable string list, for example [\"Brightfield\", \"Phase\"]</p>"},{"location":"metadata/#limnd2.metadata.calculateColor","title":"calculateColor","text":"<pre><code>calculateColor(color_string: str) -&gt; int\n</code></pre> <p>Calculates channel color integer (used as uiColor).</p> <p>Parameters:</p> Name Type Description Default <code>color_string</code> <code>str</code> <p>Color to be converted, either as hex string (\"#ff0000\"), common colors are also supported (\"Red\").</p> required <p>Returns:</p> Type Description <code>int</code> <p>converted color value</p>"},{"location":"metadata_factory/","title":"Metadata factory module","text":"<p>This module contains helper classes and functions for creating <code>PictureMetadata</code> instances using simplified parameters for channels and microscope settings. Those instances should be used with <code>Nd2Writer</code> instance for altering / creating <code>.nd2</code> files.</p> <p>Info</p> <p>Since this module is used to creating metadata data structures, you should not use any part of this module if you only read an .nd2 file.</p> <p>For creating metadata, you should use <code>MetadataFactory</code> class.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory","title":"MetadataFactory","text":"<p>Helper class for creating metada, see examples below on how to create metadata witch channels and microscope settings.</p> <p>To actually create metadata instance, make sure to call either <code>.createMetadata()</code> method or use call operator.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory--sample-usage","title":"Sample usage","text":"<p>Make sure to import MetadataFactory class before using it, optionally you can use Plane dataclass if you wish to use it.</p> <pre><code>from limnd2.metadata_factory import MetadataFactory, Plane\n</code></pre> <p>You can create channels and microscope settings on <code>MetadataFactory</code> constructor, or add them later using <code>.addPlane()</code> method.</p> <p>When you add microscope settings to <code>MetadataFactory</code> constructor, those settings will be used for all channels, unless you overwrite them by providing replacement values when creating individual channel.</p> <p>In following example <code>objective_magnification</code> is applied to all channels, <code>immersion_refractive_index</code> however is only applied to <code>Channel2</code>.</p> <p>To see whole list of microscope settings that can be applied per channel or per whole factory, see <code>Plane</code> dataclass.</p> <pre><code># Create all data on constructor (miscroscope settings and channels)\nfactory = MetadataFactory([{\"name\": \"Channel1\", \"color\": \"red\"},\n                           {\"name\": \"Channel2\", \"color\": \"blue\", \"immersion_refractive_index\" : 1.2}],\n                          pixel_calibration = 50,\n                          objective_magnification = 40.0)\n\nprint(factory.createMetadata())\n</code></pre> <p>You can also create factory instance with global microscope settings and add channels later.</p> <pre><code># Create factory instance with global microscope settings\nfactory = MetadataFactory(immersion_refractive_index= 1.5,\n                        objective_magnification= 40.0, pixel_calibration=20)\n</code></pre> <p>You can add channel using named arguments. <pre><code>factory.addPlane(name = \"Channel 1\",\n                 emission_wavelength = 500,\n                 color = \"blue\")\n</code></pre> You can add channel using <code>Plane</code> dataclass. <pre><code>factory.addPlane(Plane(name = \"Channel 2\",\n                       excitation_wavelength = 600,\n                       emission_wavelength = 700,\n                       color = \"blue\"))\n</code></pre></p> <p>Or you can add channels using a dictionary. <pre><code>factory.addPlane({\"name\": \"Channel 3\",\n                \"immersion_refractive_index\": 1.6,\n                \"objective_magnification\": 20.0})\n</code></pre></p> <p>You can also create channel, store it in a variable and modify it. <pre><code>plane = factory.addPlane({\"name\": \"Channel 4\"})\n\nplane.color = \"green\"\nplane.camera_name = \"Camera channel 4\"\nplane.modality = \"Brightfield\"\n</code></pre></p> <p>Or you can access existing channel using its index</p> <pre><code>factory.getChannel(2).pinhole_diameter = 50\nfactory.getChannel(2).microscope_name = \"Microscope for channel 3\"\nfactory.getChannel(2).color = \"green\"\n</code></pre> <p>Or you can access existing channel using its channel name</p> <pre><code>factory.getChannel(\"Channel 1\").color = \"red\"\nfactory.getChannel(\"Channel 1\").immersion_refractive_index = 1.6\n</code></pre> <p>Finally create metadata using createMetadata method <pre><code>print(factory.createMetadata())\n</code></pre></p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; PictureMetadata\n</code></pre> <p>Creates a new PictureMetadata instance from the factory settings.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.addPlane","title":"addPlane","text":"<pre><code>addPlane(plane: Plane | dict[str, Any] = None, **kwargs) -&gt; Plane\n</code></pre> <p>Adds a new channel to the factory, see examples on how to use this method and <code>Plane</code> dataclass to see what settings can be applied.</p> <p>Parameters:</p> Name Type Description Default <code>plane</code> <code>Plane | dict[str, Any]</code> <p>A <code>Plane</code> object or a dictionary with plane settings.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional settings for the plane.</p> <code>{}</code>"},{"location":"metadata_factory/#limnd2.metadata_factory.MetadataFactory.createMetadata","title":"createMetadata","text":"<pre><code>createMetadata() -&gt; PictureMetadata\n</code></pre> <p>Creates a new PictureMetadata instance from the factory settings.</p>"},{"location":"metadata_factory/#limnd2.metadata_factory.Plane","title":"Plane  <code>dataclass</code>","text":"<p>A class to represent a plane in metadata, see attributes list to see what settings can be applied.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the plane.</p> <code>modality</code> <code>str | PicturePlaneModality | PicturePlaneModalityFlags</code> <p>The modality of the plane, can be a string (e.g., fluorescence, brightfield) or an instance of PicturePlaneModality or PicturePlaneModalityFlags.</p> <code>excitation_wavelength</code> <code>int</code> <p>The excitation wavelength in nanometers.</p> <code>emission_wavelength</code> <code>int</code> <p>The emission wavelength in nanometers.</p> <code>color</code> <code>str</code> <p>The color associated with the plane.</p> <code>objective_magnification</code> <code>float</code> <p>The magnification of the objective lens. (overrides setting from MetadataFactory)</p> <code>objective_numerical_aperture</code> <code>float</code> <p>The numerical aperture of the objective lens. (overrides setting from MetadataFactory)</p> <code>zoom_magnification</code> <code>float</code> <p>The zoom magnification. (overrides setting from MetadataFactory)</p> <code>immersion_refractive_index</code> <code>float</code> <p>The refractive index of the immersion medium. (overrides setting from MetadataFactory)</p> <code>pinhole_diameter</code> <code>float</code> <p>The diameter of the pinhole. (overrides setting from MetadataFactory)</p> <code>camera_name</code> <code>str</code> <p>The name of the camera used. (overrides setting from MetadataFactory)</p> <code>microscope_name</code> <code>str</code> <p>The name of the microscope used. (overrides setting from MetadataFactory)</p>"},{"location":"nd2/","title":"Nd2","text":""},{"location":"nd2/#limnd2.nd2.Nd2Reader","title":"Nd2Reader","text":"<p>Class for reading ND2 files and its attributes, metadata, properties, image data and so on.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Reader--usage","title":"Usage","text":"<p>Create Nd2 reader instance like this (use <code>with</code> statement to automatically close a file).</p> <pre><code>import limnd2\nwith limnd2.Nd2Reader('file.nd2') as nd2:\n    attributes = nd2.imageAttributes       # to get image attributes, see ImageAttributes class\n    experiment = nd2.experiment            # to get experiments in an image, see ExperimentLevel class\n    metadata = nd2.pictureMetadata         # to get image metadata, see PictureMetadata class\n\n\n    print(f\"Image resolution: {attributes.width} x {attributes.height}, # of components: {attributes.componentCount}\")\n\n    for i in range(attributes.componentCount):\n        image = nd2.image(i)                            # get image with given sequence index\n</code></pre>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.__init__","title":"__init__","text":"<pre><code>__init__(file: FileLikeObject, *, chunker_kwargs: dict = {}) -&gt; None\n</code></pre> <p>Initializes ND2 reader.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | int | BinaryIO</code> <p>Filename of the ND2 file.</p> required <code>chunker_kwargs</code> <code>dict</code> <p>Additional parameters for chunker.</p> <code>{}</code>"},{"location":"nd2/#limnd2.nd2.Nd2Reader.image","title":"image","text":"<pre><code>image(seqindex: int) -&gt; NumpyArrayLike\n</code></pre> <p>Get image data from specified frame as NumPy array.</p> Parameters: <p>seqindex: int     Image sequence index you want to get.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer","title":"Nd2Writer","text":"<p>Experimental ND2 file writer.</p> <p>Supports encoding od all image attributes, most commonly used experiments and most of image metadata. Currently does not support encoding of Wellplates, binary layers, ROIs and any custom data and text into chunk.</p> <p>Python dataclasses encodeable by this writer inherit from LVSerializable class, in those classes attributes stored with UNKNOWN, ENCODING_NOT_IMPLEMENTED and DO_NOT_ENCODE enum will not be encoded.</p>"},{"location":"nd2/#limnd2.nd2.Nd2Writer.__init__","title":"__init__","text":"<pre><code>__init__(file: FileLikeObject, *, append: bool | None = None, chunker_kwargs: dict = {}) -&gt; None\n</code></pre> <p>Either opens existing .nd2 file for writing (adding or overwriting) chunks or creates an empty .nd2 file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path | int | BinaryIO</code> <p>Filename of the ND2 file.</p> required <code>chunker_kwargs</code> <code>dict</code> <p>Additional parameters for chunker.</p> <code>{}</code>"},{"location":"nd2file/","title":"Nd2File","text":"<p>This file serves as compatibility layer between this limnd2 library maintained by Laboratory Imaging s.r.o. (https://github.com/Laboratory-Imaging/limnd2) and nd2 library maintained by Talley Lambert (https://github.com/tlambert03/nd2) It copies the interface of nd2 library, but uses limnd2 library on the \"backend\", essentially making a wrapper around it.</p>"},{"location":"nd2file/#limnd2.nd2file.AnimParam","title":"AnimParam  <code>dataclass</code>","text":"<p>Parameters of ROI position/shape.</p>"},{"location":"nd2file/#limnd2.nd2file.AnimParam.center","title":"center  <code>property</code>","text":"<pre><code>center: XYZPoint\n</code></pre> <p>Center point as a named tuple (x, y, z).</p>"},{"location":"nd2file/#limnd2.nd2file.ChannelMeta","title":"ChannelMeta  <code>dataclass</code>","text":""},{"location":"nd2file/#limnd2.nd2file.ChannelMeta.colorRGBA","title":"colorRGBA  <code>property</code>","text":"<pre><code>colorRGBA: int\n</code></pre> <p>Return color as unsigned 4-byte (32-bit) integer in ABGR format.</p>"},{"location":"nd2file/#limnd2.nd2file.Color","title":"Color","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"nd2file/#limnd2.nd2file.Color.as_abgr_u4","title":"as_abgr_u4","text":"<pre><code>as_abgr_u4() -&gt; int\n</code></pre> <p>Return color as an unsigned 4-byte (32-bit) integer in ABGR format.</p> <p>This is the native format of NIS Elements.</p>"},{"location":"nd2file/#limnd2.nd2file.Color.as_hex","title":"as_hex","text":"<pre><code>as_hex() -&gt; str\n</code></pre> <p>Return color as a hex string.</p>"},{"location":"nd2file/#limnd2.nd2file.Color.from_abgr_u4","title":"from_abgr_u4  <code>classmethod</code>","text":"<pre><code>from_abgr_u4(val: int) -&gt; Color\n</code></pre> <p>Create a color from an unsigned 4-byte (32-bit) integer in ABGR format.</p>"},{"location":"nd2file/#limnd2.nd2file.EventMeaning","title":"EventMeaning","text":"<p>               Bases: <code>IntEnum</code></p> <p>Meanings of various event types.</p>"},{"location":"nd2file/#limnd2.nd2file.InterpType","title":"InterpType","text":"<p>               Bases: <code>IntEnum</code></p> <p>The role that the ROI plays.</p>"},{"location":"nd2file/#limnd2.nd2file.ND2File","title":"ND2File","text":""},{"location":"nd2file/#limnd2.nd2file.ND2File.experiment","title":"experiment  <code>cached</code> <code>property</code>","text":"<pre><code>experiment: list[ExpLoop]\n</code></pre> <p>ExpLoop = Union[\"TimeLoop\", \"NETimeLoop\", \"XYPosLoop\", \"ZStackLoop\", \"CustomLoop\"] LoopParams = Union[\"TimeLoopParams\", \"NETimeLoopParams\", \"XYPosLoopParams\", \"ZStackLoopParams\"]</p>"},{"location":"nd2file/#limnd2.nd2file.NETimeLoop","title":"NETimeLoop  <code>dataclass</code>","text":"<p>               Bases: <code>_Loop</code></p> <p>The time dimension of an nD experiment.</p>"},{"location":"nd2file/#limnd2.nd2file.ROI","title":"ROI  <code>dataclass</code>","text":"<p>ROI object from NIS Elements.</p>"},{"location":"nd2file/#limnd2.nd2file.RoiInfo","title":"RoiInfo  <code>dataclass</code>","text":"<p>Info associated with an ROI.</p>"},{"location":"nd2file/#limnd2.nd2file.RoiShapeType","title":"RoiShapeType","text":"<p>               Bases: <code>IntEnum</code></p> <p>The type of ROI shape.</p>"},{"location":"nd2file/#limnd2.nd2file.TimeLoop","title":"TimeLoop  <code>dataclass</code>","text":"<p>               Bases: <code>_Loop</code></p> <p>The time dimension of an experiment.</p>"}]}